#errorCatcher Echo
#encoding "UTF-8"
#import datetime

#if "-" in str($station.stn_info.latitude_f)
#set global $hemisphere = "southern-hemisphere"
#else
#set global $hemisphere = "northern-hemisphere"
#end if

var pages = ["graphs", "records", "reports", "about", "pi", "webcam", "imprint", "privacy", "forecast", "extreme", "mqttmon", "test"];
var pageName = "";
function get_pageName() {
    var sPath = window.location.pathname.replace(/\/$/, "");
    var name = sPath.substring(sPath.lastIndexOf('/') + 1);
    if (name == "" ) {
        name = "homepage";
    }
    weiherhammer_debug("Page name is: " + name);
    return name;
}

// If this page we're on now is listed as a subpage, use ".." to get to the relative root
function get_relative_url() {
    pageName = get_pageName();
    if (pages.includes(pageName)) {
        var relative_url = "..";
    } else {
        var relative_url = ".";
    }
    weiherhammer_debug("URL: Relative URL is: " + relative_url);
    return relative_url;
}

// Determine if debug is on via URL var or config setting
if (getURLvar("debug") && (getURLvar("debug") == "true" || getURLvar("debug") == "1")) {
    var weiherhammer_debug_config = true;
    weiherhammer_debug("Debug: URL debug variable enabled");
} else {
    var weiherhammer_debug_config = $weiherhammer_debug;
    weiherhammer_debug("Debug: skin.conf weiherhammer_debug enabled");
}

var moment_locale = "$system_locale_js";
moment.locale(moment_locale);
var graphgroups_raw = $charts;
var graphgroups_titles = $graphpage_titles;
var graphpage_content = $graphpage_content;
var icon_dict = {};
var forecast_data = {};

function weiherhammer_debug(message) {
    if (weiherhammer_debug_config > 0) {
        console.log(message);
    }
}

//https://www.techighness.com/post/javascript-check-key-existence-in-deeply-nested-object-or-array-without-knowing-path/
const getKeyValue = (obj, key) => {
    try {
        if (!obj || (typeof obj !== "object" && !Array.isArray(obj))) {
          return null;
        }
        else if (obj.hasOwnProperty(key)) {
          return obj[key];
        }
        else if (Array.isArray(obj)) {
          for (let i = 0; i < obj.length; i++) {
            const result = getKeyValue(obj[i], key);
            if (result !== null) {
              return result;
            }
          }
        }
        else {
          for (const k in obj) {
            const result = getKeyValue(obj[k], key);
            if (result !== null) {
              return result;
            }
          }
        }
        return null;
    } catch (err) {
        console.error(err);
    }
};

jQuery(document).ready(function() {
    // Bootstrap hover tooltips
    jQuery(function() {
        jQuery('[data-toggle="tooltip"]').tooltip()
    })

    #if $Extras.has_key('theme_toggle_enabled') and $Extras.theme_toggle_enabled == '1'
    // If the visitor has overridden the theme, keep that theme going throughout the full site and their visit.
    if (sessionStorage.getItem('theme') == "toggleOverride") {
        weiherhammer_debug("Theme: sessionStorage override in place.");
        changeTheme(sessionStorage.getItem('currentTheme'));
    }

    // Change theme if a URL variable is set
    if (window.location.search.indexOf('theme')) {
        if (window.location.search.indexOf('?theme=dark') === 0) {
            weiherhammer_debug("Theme: Setting dark theme because of URL override");
            changeTheme("dark", true);
        } else if (window.location.search.indexOf('?theme=light') === 0) {
            weiherhammer_debug("Theme: Setting light theme because of URL override");
            changeTheme("light", true);
        } else if (window.location.search.indexOf('?theme=auto') === 0) {
            weiherhammer_debug("Theme: Setting auto theme because of URL override");
            sessionStorage.setItem('theme', 'auto')
            #if $almanac.sunrise.raw is not None and $almanac.sunset.raw is not None
            autoTheme(#echo datetime.datetime.fromtimestamp($almanac.sunset.raw).strftime('%H')#, #echo datetime.datetime.fromtimestamp($almanac.sunset.raw).strftime('%M')#, #echo datetime.datetime.fromtimestamp($almanac.sunrise.raw).strftime('%H')#, #echo datetime.datetime.fromtimestamp($almanac.sunrise.raw).strftime('%M')#)
            #end if
        }
    }

    // Dark mode checkbox toggle switcher
    try {
        document.getElementById('themeSwitch').addEventListener('change', function(event) {
            weiherhammer_debug("Theme: Toggle button changed");
            (event.target.checked) ? changeTheme("dark", true) : changeTheme("light", true);
        });
    } catch (err) {
        // Silently exit
    }
    #end if

    #if $Extras.has_key('current_provider_toggle') and $Extras.current_provider_toggle == '1'
    // If the visitor has overridden the current source,provider keep that current source provider going throughout the full site and their visit.
    if (sessionStorage.getItem('current_provider_override') == "toggleOverride") {
        weiherhammer_debug("current_provider_override: sessionStorage override in place.");
        changeCurrentProviderRadio(sessionStorage.getItem('current_provider'));
    }
    // current provider switcher
    try {
        jQuery('input[type=radio][name=current_provider_radio]').click(function() {
            changeCurrentProviderRadio(this.value, true);
        });
    } catch (err) {
         // Silently exit
    }
    #end if

    // After charts are loaded, if an anchor tag is in the URL, let's scroll to it
    jQuery(window).on('load', function() {
        var anchor_tag = location.hash.replace('#', '');
        if (anchor_tag != '') {
            // Scroll the webpage to the chart. The timeout is to let jQuery finish appending the outer div so the height of the page is completed.
            setTimeout(function() {
                jQuery('html, body').animate({scrollTop: jQuery('#' + anchor_tag).offset().top}, 500);
            }, 500);
        }
    });

    #if $Extras.has_key("back_to_top_button_enabled") and $Extras.back_to_top_button_enabled == '1'
    // Back to Top Button is visible after 400px
    jQuery(window).scroll(function() {
        if (jQuery(this).scrollTop() > 400) {
            jQuery('#btn-back-to-top').css('transform', 'scale(1)');
        } else {
            jQuery('#btn-back-to-top').css('transform', 'scale(0)');
        }
    });
    #if $Extras.has_key("back_to_top_button_position") and $Extras.back_to_top_button_position == '1'
    // Button is visible on left side
    jQuery('#btn-back-to-top').css('left','20px').css('right','auto');
    #end if

    jQuery('#btn-back-to-top').click(function() {
        jQuery("html, body").animate({
            scrollTop: 0
        }, 1000);
        return false;
    });

    #if $Extras.has_key("back_to_top_button_position") and $Extras.back_to_top_button_position == '1'
    // Button is visible on left side
    jQuery('#btn-back-to-top').css('left','20px').css('right','auto');
    #end if

    #if $Extras.has_key("back_to_top_button_opacity") and $Extras.back_to_top_button_opacity >= '0.1' and $Extras.back_to_top_button_opacity <= '0.9'
    jQuery('#btn-back-to-top').css('opacity','$Extras.back_to_top_button_opacity');
    #end if

    #end if
});

#if $Extras.has_key("theme") and $Extras.theme == 'auto'
// Run this on every page for dark mode if skin theme is auto
ajaxweewx().then(function(weewx_data) { // This call will make sure json/weewx_data.json is loaded before anything else
    try {
        autoTheme(weewx_data["almanac"]["sunset_hour"], weewx_data["almanac"]["sunset_minute"], weewx_data["almanac"]["sunrise_hour"], weewx_data["almanac"]["sunrise_minute"]);
    } catch (err) {
        // Returned weewx_data does not have this value
        console.error(err);
    }
}).catch(function(e) {
    console.error(e);
});
#end if

// Disable AJAX caching
jQuery.ajaxSetup({
    cache: false
});

// Farmers rules
// TODO error handling
#if $Extras.has_key("show_farmers_rules") and $Extras.show_farmers_rules == '1'
function farmers_rules() {
    farmers_rules = {};
    jQuery.when(
        // get farmers rules
        jQuery.getJSON(get_relative_url() + "/json/farmers-rules.json", function(frules) {
            farmers_rules = frules;
        })
    ).then(function() {
        // show farmers rules
        show_farmers_rules(farmers_rules);
    });
}

// https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript
function randomIntFromInterval(min, max) { // min and max included 
    return Math.floor(Math.random() * (max - min + 1) + min)
}

function show_farmers_rules(data) {
    var dname = "No data found!";
    var frule = "No data found!";
    var grule = false;
    try {
        var month = moment().format("M");
        var day = moment().format("D");
        var today = moment().format("D. MMMM");
        weiherhammer_debug("show_farmers_rules: month: " + month);
        weiherhammer_debug("show_farmers_rules: day: " + day);
        var drcount = data.months[month].days[day].rules.length;
        weiherhammer_debug("show_farmers_rules: day rule count: " + drcount);
        var rkey = -1;

        if (drcount > 1) {
            rkey = randomIntFromInterval(1, drcount) - 1;
            weiherhammer_debug("show_farmers_rules: day rule using random idx: " + rkey);
        } else if (drcount == 1) {
            rkey = 0;
            weiherhammer_debug("show_farmers_rules: day rule using idx: " + rkey);
        } else {
            var grcount = data.months[month].general.rules.length;
            weiherhammer_debug("show_farmers_rules: general rule count: " + grcount);
            if (grcount > 1) {
                rkey = randomIntFromInterval(1, grcount) - 1;
                weiherhammer_debug("show_farmers_rules: general rule using random idx: " + rkey);
                grule = true;
            } else if (grcount == 1) {
                rkey = 0;
                weiherhammer_debug("show_farmers_rules: general rule using idx: " + rkey);
                grule = true;
            }
        }
        if (rkey >= 0) {
            jQuery(".farmers-rules-title").html('$obs.label.farmers_rules_title');
            var datasource_url = data.datasource_url;
            if (grule) {
                frule = data.months[month].general.rules[rkey];
                month = moment().format("MMMM");
                jQuery(".farmers-rules-day").html('$obs.label.farmers_rules_grule&nbsp;' + month);
                datasource_url += ('#' + month);
            } else {
                dname = data.months[month].days[day].name;
                var danchor = '';
                if (data.months[month].days[day].hasOwnProperty('anchor')) {
                    danchor = data.months[month].days[day].anchor;
                }
                frule = data.months[month].days[day].rules[rkey];
                jQuery(".farmers-rules-day").html('$obs.label.farmers_rules_drule&nbsp;' + today + (dname == ''?'':'&nbsp;-&nbsp;' + dname));
                // https://stackoverflow.com/questions/1983648/replace-spaces-with-dashes-and-make-all-letters-lower-case
                if (danchor == '') {
                    datasource_url += ('#' + today.replace(/\s+/g,"_") + (dname == ''?'':':_' + dname.replace(/\s+/g,"_")));
                } else {
                    datasource_url += danchor;
                }
            }
            jQuery(".farmers-rules-rule").html(frule);
            jQuery(".farmers-rules-source").html('$obs.label.farmers_rules_source:&nbsp;<a href="' + datasource_url + '" target="_blank" rel="noreferrer">' + data.datasource + '</a>');
        }
    } catch (err) {
        weiherhammer_debug("show_farmers_rules: Returned data does not have this value");
    }
    weiherhammer_debug("show_farmers_rules: day: " + dname);
    weiherhammer_debug("show_farmers_rules: rule: " + frule);
}
#end if

// Get the URL variables. Source: https://stackoverflow.com/a/26744533/1177153
function getURLvar(k) {
    var p = {};
    location.search.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(s, k, v) {p[k] = v});
    return k ? p[k] : p;
}

// http://stackoverflow.com/a/14887961/1177153
var weatherdirection = $obs.label.graphs_windDir_ordinals;

// Change the color of the outTemp_F variable
function get_outTemp_color(unit, outTemp, returnColor = false) {
    outTemp = parseFloat(outTemp).toFixed(0); // Convert back to decimal literal
    if (unit == "degree_F") {
        if (outTemp <= 0) {
            var outTemp_color = "#1278c8";
        } else if (outTemp <= 25) {
            var outTemp_color = "#30bfef";
        } else if (outTemp <= 32) {
            var outTemp_color = "#1fafdd";
        } else if (outTemp <= 40) {
            var outTemp_color = "rgba(0,172,223,1)";
        } else if (outTemp <= 50) {
            var outTemp_color = "#71bc3c";
        } else if (outTemp <= 55) {
            var outTemp_color = "rgba(90,179,41,0.8)";
        } else if (outTemp <= 65) {
            var outTemp_color = "rgba(131,173,45,1)";
        } else if (outTemp <= 70) {
            var outTemp_color = "rgba(206,184,98,1)";
        } else if (outTemp <= 75) {
            var outTemp_color = "rgba(255,174,0,0.9)";
        } else if (outTemp <= 80) {
            var outTemp_color = "rgba(255,153,0,0.9)";
        } else if (outTemp <= 85) {
            var outTemp_color = "rgba(255,127,0,1)";
        } else if (outTemp <= 90) {
            var outTemp_color = "rgba(255,79,0,0.9)";
        } else if (outTemp <= 95) {
            var outTemp_color = "rgba(255,69,69,1)";
        } else if (outTemp <= 110) {
            var outTemp_color = "rgba(255,104,104,1)";
        } else if (outTemp >= 111) {
            var outTemp_color = "rgba(218,113,113,1)";
        }
    } else if (unit == "degree_C") {
        if (outTemp <= 0) {
            var outTemp_color = "#1278c8";
        } else if (outTemp <= -3.8) {
            var outTemp_color = "#30bfef";
        } else if (outTemp <= 0) {
            var outTemp_color = "#1fafdd";
        } else if (outTemp <= 4.4) {
            var outTemp_color = "rgba(0,172,223,1)";
        } else if (outTemp <= 10) {
            var outTemp_color = "#71bc3c";
        } else if (outTemp <= 12.7) {
            var outTemp_color = "rgba(90,179,41,0.8)";
        } else if (outTemp <= 18.3) {
            var outTemp_color = "rgba(131,173,45,1)";
        } else if (outTemp <= 21.1) {
            var outTemp_color = "rgba(206,184,98,1)";
        } else if (outTemp <= 23.8) {
            var outTemp_color = "rgba(255,174,0,0.9)";
        } else if (outTemp <= 26.6) {
            var outTemp_color = "rgba(255,153,0,0.9)";
        } else if (outTemp <= 29.4) {
            var outTemp_color = "rgba(255,127,0,1)";
        } else if (outTemp <= 32.2) {
            var outTemp_color = "rgba(255,79,0,0.9)";
        } else if (outTemp <= 35) {
            var outTemp_color = "rgba(255,69,69,1)";
        } else if (outTemp <= 43.3) {
            var outTemp_color = "rgba(255,104,104,1)";
        } else if (outTemp >= 43.4) {
            var outTemp_color = "rgba(218,113,113,1)";
        }
    }

    // Return the color value if requested, otherwise just set the div color
    if (returnColor) {
        return outTemp_color;
    } else {
        jQuery(".outtemp_outer").css("color", outTemp_color);
    }
}

// Change the color of the aqi variable according to US-EPA standards
// (adjusted to match skin colors better)
//TODO ==> UBA colors
function get_aqi_color(aqi, returnColor = false) {
    if (aqi >= 301) {
        var aqi_color = "#cc241d";
    } else if (aqi >= 201) {
        var aqi_color = "#b16286";
    } else if (aqi >= 151) {
        var aqi_color = "rgba(255,69,69,1)";
    } else if (aqi >= 101) {
        var aqi_color = "rgba(255,127,0,1)";
    } else if (aqi >= 51) {
        var aqi_color = "rgba(255,174,0,0.9)";
    } else if (aqi < 51) {
        var aqi_color = "#71bc3c";
    }

    // Return the color value if requested, otherwise just set the div color
    if (returnColor) {
        return aqi_color;
    } else {
        jQuery(".aqi_outer").css("color", aqi_color);
    }
}

// Change the color/label of the aqi category (aqi level) according to Umweltbundesamt standards
function update_aqi_properties(data, aqi, value, options=[]) {
    try {
        value = parseInt(value).toString();

        // fallback for all possible properties
        var title = "$gettext('unknown')";
        var txt = "$gettext('unknown')";
        var color = "#dfdfdf";

        // data for all possible properties
        if (data.hasOwnProperty("aqilevel") && data["aqilevel"].hasOwnProperty(value)) {
            if (data["aqilevel"][value].hasOwnProperty("ttt")) {
                title = data["aqilevel"][value]["ttt"];
            }
            if (data["aqilevel"][value].hasOwnProperty("text")) {
                txt = data["aqilevel"][value]["text"];
            }
            if (data["aqilevel"][value].hasOwnProperty("color")) {
                color = data["aqilevel"][value]["color"];
            }
        }

        var cnt = options.length; // 0 = all
        if (cnt == 0) {
            options = ["all"];
        }

        for (i = 0; i < options.length; i++) {
            if (options[i] == "all" || options[i] == "title") {
                jQuery("." + aqi).prop("title", title);
                jQuery("." + aqi + "_category").prop("title", title);
                jQuery("." + aqi + "_dot").prop("title", title);
                jQuery("." + aqi + "_text").prop("title", title);
            }
            if (options[i] == "all" || options[i] == "text") {
                jQuery("." + aqi + "_text").html(txt);
            }
            if (options[i] == "all" || options[i] == "color") {
                jQuery("." + aqi).css("background-color", color);
                jQuery("." + aqi + "_category").css("background-color", color);
                jQuery("." + aqi + "_dot").css("background-color", color);
                jQuery("." + aqi + "_text").css("background-color", color);
            }
        }
    } catch (e) {
        console.error("ERROR update_aqi_properties", e);
    }
}

// Change the color/label/title of the battery observations
function update_battery_properties(data, sensor, sensorclass, value, options=[]) {
    try {
        value = parseInt(value).toString();

        // fallback for all possible properties
        var title = "$gettext('unknown')";
        var txt = "$gettext('unknown')";
        var color = "inherit";
        var symbol = "bi bi-question";

        // data for all possible properties
        if (data.hasOwnProperty("batterylevel") && 
               data["batterylevel"].hasOwnProperty(sensorclass) && 
               data["batterylevel"][sensorclass].hasOwnProperty(value)) {
            if (data["batterylevel"][sensorclass][value]["ttt"]) {
                title = data["batterylevel"][sensorclass][value]["ttt"];
            }
            if (data["batterylevel"][sensorclass][value]["text"]) {
                txt = data["batterylevel"][sensorclass][value]["text"];
            }
            if (data["batterylevel"][sensorclass][value]["color"]) {
                color = data["batterylevel"][sensorclass][value]["color"];
            }
            if (data["batterylevel"][sensorclass][value]["symbol"]) {
                symbol = data["batterylevel"][sensorclass][value]["symbol"];
            }
        }

        var cnt = options.length; // 0 = all
        if (cnt == 0) {
            options = ["all"];
        }

        for (i = 0; i < options.length; i++) {
            if (options[i] == "all" || options[i] == "title") {
                jQuery("." + sensor).prop("title", title);
                jQuery("." + sensor + "_text").prop("title", title);
                jQuery("." + sensor + "_percent").prop("title", title);
                jQuery("." + sensor + "_symbol").prop("title", title);
            }
            if (options[i] == "all" || options[i] == "color") {
                jQuery("." + sensor).css("color", color);
                jQuery("." + sensor + "_text").css("color", color);
                jQuery("." + sensor + "_percent").css("color", color);
                jQuery("." + sensor + "_symbol").css("color", color);
            }
            if (options[i] == "all" || options[i] == "text") {
                jQuery("." + sensor + "_text").html(txt);
            }
            if (options[i] == "all" || options[i] == "symbol") {
                jQuery("." + sensor + "_symbol").html('<i class="' + symbol + '"</i>');
            }
        }
    } catch (e) {
        console.error("ERROR update_battery_properties", e);
    }
}

// Change the color/label/title of the voltage observations
function update_voltage_properties(data, sensor, sensorclass, value, options=[]) {
    try {
        if (sensorclass == "solar") {
            value = parseInt(value).toString();
        } else {
            value = parseFloat(value).toFixed(1).toString();
        }

        // fallback for all possible properties
        var title = "$gettext('unknown')";
        var txt = "$gettext('unknown')";
        var color = "inherit";
        var symbol = "bi bi-question";

        // data for all possible properties
        if (data.hasOwnProperty("voltagelevel") && 
               data["voltagelevel"].hasOwnProperty(sensorclass) && 
               data["voltagelevel"][sensorclass].hasOwnProperty(value)) {
            if (data["voltagelevel"][sensorclass][value]["ttt"]) {
                title = data["voltagelevel"][sensorclass][value]["ttt"];
            }
            if (data["voltagelevel"][sensorclass][value]["text"]) {
                txt = data["voltagelevel"][sensorclass][value]["text"];
            }
            if (data["voltagelevel"][sensorclass][value]["color"]) {
                color = data["voltagelevel"][sensorclass][value]["color"];
            }
            if (data["voltagelevel"][sensorclass][value]["symbol"]) {
                symbol = data["voltagelevel"][sensorclass][value]["symbol"];
            }
        }

        var cnt = options.length; // 0 = all
        if (cnt == 0) {
            options = ["all"];
        }

        for (i = 0; i < options.length; i++) {
            if (options[i] == "all" || options[i] == "title") {
                jQuery("." + sensor).prop("title", title);
                jQuery("." + sensor + "_text").prop("title", title);
                jQuery("." + sensor + "_percent").prop("title", title);
                jQuery("." + sensor + "_symbol").prop("title", title);
            }
            if (options[i] == "all" || options[i] == "color") {
                jQuery("." + sensor).css("color", color);
                jQuery("." + sensor + "_text").css("color", color);
                jQuery("." + sensor + "_percent").css("color", color);
                jQuery("." + sensor + "_symbol").css("color", color);
            }
            if (options[i] == "all" || options[i] == "text") {
                jQuery("." + sensor + "_text").html(txt);
            }
            if (options[i] == "all" || options[i] == "symbol") {
                jQuery("." + sensor + "_symbol").html('<i class="' + symbol + '"</i>');
            }
        }
    } catch (e) {
        console.error("ERROR update_voltage_properties", e);
    }
}

// Change the color/label/title of the signal observations
function update_signal_properties(data, sensor, value, options=[]) {
    try {
        value = parseInt(value).toString();

        // fallback for all possible properties
        var title = "$gettext('unknown')";
        var txt = "$gettext('unknown')";
        var color = "inherit";
        var symbol = "bi bi-question";

        // data for all possible properties
        if (data.hasOwnProperty("signallevel") && data["signallevel"].hasOwnProperty(value)) {
            if (data["signallevel"][value]["ttt"]) {
                title = data["signallevel"][value]["ttt"];
            }
            if (data["signallevel"][value]["text"]) {
                txt = data["signallevel"][value]["text"];
            }
            if (data["signallevel"][value]["color"]) {
                color = data["signallevel"][value]["color"];
            }
            if (data["signallevel"][value]["symbol"]) {
                symbol = data["signallevel"][value]["symbol"];
            }
        }

        var cnt = options.length; // 0 = all
        if (cnt == 0) {
            options = ["all"];
        }

        for (i = 0; i < options.length; i++) {
            if (options[i] == "all" || options[i] == "title") {
                jQuery("." + sensor).prop("title", title);
                jQuery("." + sensor + "_text").prop("title", title);
                jQuery("." + sensor + "_percent").prop("title", title);
                jQuery("." + sensor + "_symbol").prop("title", title);
            }
            if (options[i] == "all" || options[i] == "color") {
                jQuery("." + sensor).css("color", color);
                jQuery("." + sensor + "_text").css("color", color);
                jQuery("." + sensor + "_percent").css("color", color);
                jQuery("." + sensor + "_symbol").css("color", color);
            }
            if (options[i] == "all" || options[i] == "text") {
                jQuery("." + sensor + "_text").html(txt);
            }
            if (options[i] == "all" || options[i] == "symbol") {
                jQuery("." + sensor + "_symbol").html('<i class="' + symbol + '"</i>');
            }
        }
    } catch (e) {
        console.error("ERROR update_signal_properties", e);
    }
}

// Change the color/label/title of the switch observations
function update_switch_properties(data, sensor, colorlogic, value, options=[]) {
    try {
        value = parseInt(value).toString();

        // fallback for all possible properties
        var title = "$gettext('unknown')";
        var txt = "$gettext('unknown')";
        var color = "inherit";

        // data for all possible properties
        if (data.hasOwnProperty("switchlevel") && data["switchlevel"].hasOwnProperty(value)) {
            if (data["switchlevel"][value]["ttt"]) {
                var title = data["switchlevel"][value]["ttt"];
            }
            if (data["switchlevel"][value]["text"]) {
                var txt = data["switchlevel"][value]["text"];
            }
            if (data["switchlevel"][value]["color" + "_" + colorlogic]) {
                var color = data["switchlevel"][value]["color" + "_" + colorlogic];
            }
        }

        var cnt = options.length; // 0 = all
        if (cnt == 0) {
            options = ["all"];
        }

        for (i = 0; i < options.length; i++) {
            if (options[i] == "all" || options[i] == "title") {
                jQuery("." + sensor).prop("title", title);
                jQuery("." + sensor + "_text").prop("title", title);
            }
            if (options[i] == "all" || options[i] == "text") {
                jQuery("." + sensor + "_text").html(txt);
            }
            if (options[i] == "all" || options[i] == "color") {
                jQuery("." + sensor).css("color", color);
                jQuery("." + sensor + "_text").css("color", color);
            }
        }
    } catch (e) {
        console.error("ERROR update_switch_properties", e);
    }
}

// Change the color/label/title of the indoor quality
function update_roomclimate_properties(data, options=[]) {

    if (!weewx_data['roomclimate_extension_config'].hasOwnProperty('observations')) {
        return;
    } else if (weewx_data['roomclimate_extension_config'].hasOwnProperty('enabled')) {
        if (!to_bool(weewx_data['roomclimate_extension_config']['enabled'])) {
            return;
        }
    } else if (!weewx_data.hasOwnProperty('roomclimate')) {
        return;
    } else if (!vdp_array.hasOwnProperty('roomclimate')) {
        return;
    } else if (!vdp_array['roomclimate'].hasOwnProperty('obs')) {
        return;
    }

    var cnt = options.length; // 0 = all
    if (cnt == 0) {
        options = ["all"];
    }

    // fallback for all possible properties
    var fbtitle = "$gettext('unknown')";
    var fbtxt = "$gettext('unknown')";
    var fbcolor = "";

    try {
        //console.log('update_roomclimate_properties');
        for (const [obs, obsConf] of Object.entries(weewx_data['roomclimate_extension_config']['observations'])) {
            var room = obsConf['location'];
            var group = obsConf['group'];
            //console.log("obs room group", obs, room, group);
            if (data.hasOwnProperty(obs)) {
                if (group == "temperature") {
                    // Temperature and Temperature Quality Index
                    if (data.hasOwnProperty(room + "_tqi")) {
                        var title = fbtitle;
                        var txt = fbtxt;
                        var color = fbcolor;
                        var qi = parseInt(data[room + "_tqi"]).toString();
                        if (weewx_data.hasOwnProperty("roomclimate")) {
                            if (weewx_data["roomclimate"].hasOwnProperty(group)) {
                                if (weewx_data["roomclimate"][group].hasOwnProperty(qi)) {
                                    if (weewx_data["roomclimate"][group][qi].hasOwnProperty("ttt")) {
                                        title = weewx_data["roomclimate"][group][qi]["ttt"];
                                    }
                                    if (weewx_data["roomclimate"][group][qi].hasOwnProperty("text")) {
                                        txt = weewx_data["roomclimate"][group][qi]["text"];
                                    }
                                    if (weewx_data["roomclimate"][group][qi].hasOwnProperty("color")) {
                                        color = weewx_data["roomclimate"][group][qi]["color"];
                                    }
                                }
                            }
                        }

                        //console.log("tqi color txt title ", qi,color,txt,title);
                        for (var i = 0; i < options.length; i++) {
                            if (options[i] == "all" || options[i] == "title") {
                                if (vdp_array['roomclimate']['obs'].includes(obs)) {
                                    jQuery('.' + obs).attr('title', title);
                                }
                                if (vdp_array['roomclimate']['obs'].includes(room + "_tqi")) {
                                    jQuery('.' + room + "_tqi").attr('title', title);
                                    jQuery('.' + room + "_tqi_text").attr('title', title);
                                }
                            }
                            if (options[i] == "all" || options[i] == "text") {
                                if (vdp_array['roomclimate']['obs'].includes(room + "_tqi")) {
                                    jQuery('.' + room + "_tqi_text").html(txt);
                                }
                            }
                            if (options[i] == "all" || options[i] == "color") {
                                if (vdp_array['roomclimate']['obs'].includes(obs)) {
                                    jQuery('.' + obs).css('color', color);
                                }
                                if (vdp_array['roomclimate']['obs'].includes(room + "_tqi")) {
                                    jQuery('.' + room + "_tqi").css('color', color);
                                    jQuery('.' + room + "_tqi_text").css('color', color);
                                }
                            }
                        }
                    }
                } else if (group == "humidity") {
                    // Humidity and Humidity Quality Index
                    if (data.hasOwnProperty(room + "_hqi")) {
                        var title = fbtitle;
                        var txt = fbtxt;
                        var color = fbcolor;
                        var qi = parseInt(data[room + "_hqi"]).toString();
                        if (weewx_data.hasOwnProperty("roomclimate")) {
                            if (weewx_data["roomclimate"].hasOwnProperty(group)) {
                                if (weewx_data["roomclimate"][group].hasOwnProperty(qi)) {
                                    if (weewx_data["roomclimate"][group][qi].hasOwnProperty("ttt")) {
                                        title = weewx_data["roomclimate"][group][qi]["ttt"];
                                    }
                                    if (weewx_data["roomclimate"][group][qi].hasOwnProperty("text")) {
                                        txt = weewx_data["roomclimate"][group][qi]["text"];
                                    }
                                    if (weewx_data["roomclimate"][group][qi].hasOwnProperty("color")) {
                                        color = weewx_data["roomclimate"][group][qi]["color"];
                                    }
                                }
                            }
                        }

                        //console.log("hqi color txt title ", qi,color,txt,title);
                        for (var i = 0; i < options.length; i++) {
                            if (options[i] == "all" || options[i] == "title") {
                                if (vdp_array['roomclimate']['obs'].includes(obs)) {
                                    jQuery('.' + obs).attr('title', title);
                                }
                                if (vdp_array['roomclimate']['obs'].includes(room + "_hqi")) {
                                    jQuery('.' + room + "_hqi").attr('title', title);
                                    jQuery('.' + room + "_hqi_text").attr('title', title);
                                }
                            }
                            if (options[i] == "all" || options[i] == "text") {
                                if (vdp_array['roomclimate']['obs'].includes(room + "_hqi")) {
                                    jQuery('.' + room + "_hqi_text").html(txt);
                                }
                            }
                            if (options[i] == "all" || options[i] == "color") {
                                if (vdp_array['roomclimate']['obs'].includes(obs)) {
                                    jQuery('.' + obs).css('color', color);
                                }
                                if (vdp_array['roomclimate']['obs'].includes(room + "_hqi")) {
                                    jQuery('.' + room + "_hqi").css('color', color);
                                    jQuery('.' + room + "_hqi_text").css('color', color);
                                }
                            }
                        }
                    }
                }
            }

            // Room Quality Index
            if (data.hasOwnProperty(room + "_rqi") && vdp_array['roomclimate']['obs'].includes(room + "_rqi")) {
                var title = fbtitle;
                var txt = fbtxt;
                var color = fbcolor;
                var group = "room";
                var qi = parseInt(data[room + "_rqi"]).toString();
                if (weewx_data.hasOwnProperty("roomclimate")) {
                    if (weewx_data["roomclimate"].hasOwnProperty(group)) {
                        if (weewx_data["roomclimate"][group].hasOwnProperty(qi)) {
                            if (weewx_data["roomclimate"][group][qi].hasOwnProperty("ttt")) {
                                title = weewx_data["roomclimate"][group][qi]["ttt"];
                            }
                            if (weewx_data["roomclimate"][group][qi].hasOwnProperty("text")) {
                                txt = weewx_data["roomclimate"][group][qi]["text"];
                            }
                            if (weewx_data["roomclimate"][group][qi].hasOwnProperty("color")) {
                                color = weewx_data["roomclimate"][group][qi]["color"];
                            }

                            //console.log("rqi color txt title ", qi,color,txt,title);
                            for (var i = 0; i < options.length; i++) {
                                if (options[i] == "all" || options[i] == "title") {
                                    jQuery('.' + room + "_rqi").attr('title', title);
                                    jQuery('.' + room + "_rqi_text").attr('title', title);
                                }
                                if (options[i] == "all" || options[i] == "text") {
                                    jQuery('.' + room + "_rqi_text").html(txt);
                                }
                                if (options[i] == "all" || options[i] == "color") {
                                    jQuery('.' + room + "_rqi").css('color', color);
                                    jQuery('.' + room + "_rqi_text").css('color', color);
                                }
                            }
                        }
                    }
                }
            }
        }
    } catch (e) {
        console.error("ERROR update_roomclimate_properties", e);
    }
}

// Change the color/label/title/arrow of the pressure trend
function update_pressure_trend_properties(data, trend_obs, value=null) {
    const RISING_VERY_RAPIDLY = "4";
    const RISING_QUICKLY = "3";
    const RISING = "2";
    const RISING_SLOWLY = "1";
    const STEADY = "0";
    const FALLING_SLOWLY = "-1";
    const FALLING = "-2";
    const FALLING_QUICKLY = "-3";
    const FALLING_VERY_RAPIDLY = "-4";
    var trend_value = null;
    var trend_code = "$gettext('unknown')";
    var symbol_rotation = null;
    var symbol_output = "";

    try {
        if (value == null) {
            // data is weewx_data
            if (data.hasOwnProperty("trend")) {
                if (data["trend"].hasOwnProperty(trend_obs)) {
                    if (data["trend"][trend_obs].hasOwnProperty("raw")) {
                        trend_value = parseFloat(data["trend"][trend_obs]["raw"]).toPrecision(1);
                    }
                }
            }
        } else {
            trend_value = parseFloat(value).toPrecision(1);
        }
        // console.log("trend_obs trend_value value",trend_obs,trend_value,value);

        if (trend_value != null) {
            if (trend_value > 6.0) {
                trend_code = RISING_VERY_RAPIDLY;
            } else if  (trend_value > 3.5) {
                trend_code = RISING_QUICKLY;
            } else if  (trend_value > 1.5) {
                trend_code = RISING;
            } else if  (trend_value >= 0.1) {
                trend_code = RISING_SLOWLY;
            } else if  (trend_value > -0.1) {
                trend_code = STEADY;
            } else if  (trend_value >= -1.5) {
                trend_code = FALLING_SLOWLY;
            } else if  (trend_value >= -3.5) {
                trend_code = FALLING;
            } else if  (trend_value >= -6.0) {
                trend_code = FALLING_QUICKLY;
            } else {
                trend_code = FALLING_VERY_RAPIDLY;
            }
        }
        //console.log("trend_code",trend_code);

        if (!data["trend"].hasOwnProperty("pressuretrend")) {
            if (!data["trend"]["pressuretrend"].hasOwnProperty(trend_code)) {
                trend_code = "$gettext('unknown')";
            }
        } else {
            if (trend_code == RISING_VERY_RAPIDLY) {
                symbol_rotation = 0.0;
            } else if (trend_code == RISING_QUICKLY) {
                symbol_rotation = 22.5;
            } else if (trend_code == RISING) {
                symbol_rotation = 45.0;
            } else if (trend_code == RISING_SLOWLY) {
                symbol_rotation = 67.5;
            } else if (trend_code == STEADY) {
                symbol_rotation = 90.0;
            } else if (trend_code == FALLING_SLOWLY) {
                symbol_rotation = 112.5;
            } else if (trend_code == FALLING) {
                symbol_rotation = 135.0;
            } else if (trend_code == FALLING_QUICKLY) {
                symbol_rotation = 157.5;
            } else if (trend_code == FALLING_VERY_RAPIDLY) {
                symbol_rotation = 180.0;
            }
        }

        if (symbol_rotation != null) {
            symbol_output = '<i class="';
            if (symbol_rotation == 0.0) {
                symbol_output += data["trend"]["pressuretrend"]["symbol-up"];
            } else if (symbol_rotation == 90.0) {
                symbol_output += data["trend"]["pressuretrend"]["symbol-right"];
            } else if (symbol_rotation == 180.0) {
                symbol_output += data["trend"]["pressuretrend"]["symbol-down"];
            } else {
                symbol_output += data["trend"]["pressuretrend"]["symbol-up"];
                symbol_output += '" style="transform:rotate(' + symbol_rotation + 'deg);';
            }
            symbol_output += '"></i>';
        }

        jQuery("." + trend_obs).attr('title', data["trend"]["pressuretrend"][trend_code]["ttt"]);
        jQuery(".trend_" + trend_obs).attr('title', data["trend"]["pressuretrend"][trend_code]["ttt"]);

        jQuery(".trend_" + trend_obs + "_symbol").html(symbol_output);
        jQuery(".trend_" + trend_obs + "_symbol").attr('title', data["trend"]["pressuretrend"][trend_code]["ttt"]);

        jQuery(".trend_" + trend_obs + "_text").html(data["trend"]["pressuretrend"][trend_code]["text"]);
        jQuery(".trend_" + trend_obs + "_text").attr('title', data["trend"]["pressuretrend"][trend_code]["ttt"]);

    } catch (e) {
        console.error("ERROR update_pressure_trend_properties", e);
    }
}

function get_gauge_color(value, options) {
    if (options.color1) {
        // Failsafe in case value drops below the lowest color position user has set.
        // Otherwise color is undefined when the value is below color1_position
        var color = options.color1
    }
    if (options.color2) {
        if (value >= options.color2_position) {
            var color = options.color2
        }
    }
    if (options.color3) {
        if (value >= options.color3_position) {
            var color = options.color3
        }
    }
    if (options.color4) {
        if (value >= options.color4_position) {
            var color = options.color4
        }
    }
    if (options.color5) {
        if (value >= options.color5_position) {
            var color = options.color5
        }
    }
    if (options.color6) {
        if (value >= options.color6_position) {
            var color = options.color6
        }
    }
    if (options.color7) {
        if (value >= options.color7_position) {
            var color = options.color7
        }
    }
    return color
}

function get_gauge_label(value, options) {
    if (options.color1) {
        if (options.color1_label) {
            var label = options.color1_label
        }
    }
    if (options.color2) {
        if (value >= options.color2_position) {
            var label = null
            if (options.color2_label) {
                var label = options.color2_label
            }
        }
    }
    if (options.color3) {
        if (value >= options.color3_position) {
            var label = null
            if (options.color3_label) {
                var label = options.color3_label
            }
        }
    }
    if (options.color4) {
        if (value >= options.color4_position) {
            var label = null
            if (options.color4_label) {
                var label = options.color4_label
            }
        }
    }
    if (options.color5) {
        if (value >= options.color5_position) {
            var label = null
            if (options.color5_label) {
                var label = options.color5_label
            }
        }
    }
    if (options.color6) {
        if (value >= options.color6_position) {
            var label = null
            if (options.color6_label) {
                var label = options.color6_label
            }
        }
    }
    if (options.color7) {
        if (value >= options.color7_position) {
            var label = null
            if (options.color7_label) {
                var label = options.color7_label
            }
        }
    }
    return label
}

function kts_to_beaufort(windspeed) {
    // Given windspeed in knots, converts to Beaufort scale
    if (windspeed <= 1) {
        return 0
    } else if (windspeed <= 3) {
        return 1
    } else if (windspeed <= 6) {
        return 2
    } else if (windspeed <= 10) {
        return 3
    } else if (windspeed <= 15) {
        return 4
    } else if (windspeed <= 21) {
        return 5
    } else if (windspeed <= 27) {
        return 6
    } else if (windspeed <= 33) {
        return 7
    } else if (windspeed <= 40) {
        return 8
    } else if (windspeed <= 47) {
        return 9
    } else if (windspeed <= 55) {
        return 10
    } else if (windspeed <= 63) {
        return 11
    } else if (windspeed > 63) {
        return 12
    }
}

function beaufort_cat(beaufort) {
    // Given Beaufort number, returns category description
    switch (beaufort) {
        case 0:
            return "$beaufort0"
        case 1:
            return "$beaufort1"
        case 2:
            return "$beaufort2"
        case 3:
            return "$beaufort3"
        case 4:
            return "$beaufort4"
        case 5:
            return "$beaufort5"
        case 6:
            return "$beaufort6"
        case 7:
            return "$beaufort7"
        case 8:
            return "$beaufort8"
        case 9:
            return "$beaufort9"
        case 10:
            return "$beaufort10"
        case 11:
            return "$beaufort11"
        case 12:
            return "$beaufort12"
    }
}

function highcharts_tooltip_factory(obsvalue, point_obsType, highchartsReturn = false, rounding, mirrored = false, numberFormat) {
    // Mirrored values have the negative sign removed
    if (mirrored) {
        obsvalue = Math.abs(obsvalue);
    }

    if (point_obsType == "windDir") {
        if (obsvalue >= 0 && obsvalue <= 11.25) {
            ordinal = "$ordinate_names[0]"; // N
        } else if (obsvalue >= 11.26 && obsvalue <= 33.75) {
            ordinal = "$ordinate_names[1]"; // NNE
        } else if (obsvalue >= 33.76 && obsvalue <= 56.25) {
            ordinal = "$ordinate_names[2]"; // NE
        } else if (obsvalue >= 56.26 && obsvalue <= 78.75) {
            ordinal = "$ordinate_names[3]"; // ENE
        } else if (obsvalue >= 78.76 && obsvalue <= 101.25) {
            ordinal = "$ordinate_names[4]"; // E
        } else if (obsvalue >= 101.26 && obsvalue <= 123.75) {
            ordinal = "$ordinate_names[5]"; // ESE
        } else if (obsvalue >= 123.76 && obsvalue <= 146.25) {
            ordinal = "$ordinate_names[6]"; // SE
        } else if (obsvalue >= 146.26 && obsvalue <= 168.75) {
            ordinal = "$ordinate_names[7]"; // SSE
        } else if (obsvalue >= 168.76 && obsvalue <= 191.25) {
            ordinal = "$ordinate_names[8]"; // S
        } else if (obsvalue >= 191.26 && obsvalue <= 213.75) {
            ordinal = "$ordinate_names[9]"; // SSW
        } else if (obsvalue >= 213.76 && obsvalue <= 236.25) {
            ordinal = "$ordinate_names[10]"; // SW
        } else if (obsvalue >= 236.26 && obsvalue <= 258.75) {
            ordinal = "$ordinate_names[11]"; // WSW
        } else if (obsvalue >= 258.76 && obsvalue <= 281.25) {
            ordinal = "$ordinate_names[12]"; // W
        } else if (obsvalue >= 281.26 && obsvalue <= 303.75) {
            ordinal = "$ordinate_names[13]"; // WNW
        } else if (obsvalue >= 303.76 && obsvalue <= 326.25) {
            ordinal = "$ordinate_names[14]"; // NW
        } else if (obsvalue >= 326.26 && obsvalue <= 348.75) {
            ordinal = "$ordinate_names[15]"; // NNW
        } else if (obsvalue >= 348.76 && obsvalue <= 360) {
            ordinal = "$ordinate_names[0]"; // N
        }

        // highchartsReturn returns the full wind direction string for highcharts tooltips. e.g "NNW (337)"
        if (highchartsReturn) {
            output = ordinal + " (" + Math.round(obsvalue) + "\xBA)";
        } else {
            output = ordinal;
        }
    } else {
        try {
            // Setup any graphs.conf overrides on formatting
            var {decimals, decimalPoint, thousandsSep} = numberFormat;

            // Try to apply the highcharts numberFormat for locale awareness. Use rounding from weewx.conf StringFormats.
            // -1 is set from Python to notate no rounding data available and decimals from graphs.conf is undefined.
            if (rounding == "-1" && typeof decimals === "undefined") {
                output = Highcharts.numberFormat(obsvalue);
            } else {
                // If the amount of decimal is defined, use that instead since rounding is provided to the function.
                if (typeof decimals !== "undefined") {
                    rounding = decimals;
                }
                // If decimalPoint is undefined, use the auto detect from the skin since this comes from the skin.
                if (typeof decimalPoint === "undefined") {
                    decimalPoint = "$highcharts_decimal";
                }
                // If thousandsSep is undefined, use the auto detect from the skin since this comes from the skin.
                if (typeof thousandsSep === "undefined") {
                    thousandsSep = "$highcharts_thousands";
                }

                output = Highcharts.numberFormat(obsvalue, rounding, decimalPoint, thousandsSep);
            }
        } catch (err) {
            // Fall back to just returning the highcharts point number value, which is a best guess.
            output = Highcharts.numberFormat(obsvalue);
        }
    }

    return output;
}

// Handle wind arrow rotation with the ability to "rollover" past 0 
// without spinning back around. e.g 350 to 3 would normally spin back around
// https://stackoverflow.com/a/19872672/1177153
function rotateWindDir(newRotation, windSpeed="N/A") {
    if (newRotation == "N/A") {
        // jQuery(".arrow").css("visibility", "hidden");
        // //jQuery(".arrow").css('opacity','0.5');
        // jQuery(".curwinddeg").html("-");
        // jQuery(".curwinddir").html("--");
        return;
    }
    // if (windSpeed != "N/A") {
        // windSpeed = windSpeed || 0.0; // if windSpeed undefined make 0.0, else windSpeed
        // if (windSpeed == 0.0) {
            // jQuery(".arrow").css("visibility", "hidden");
            // //jQuery(".arrow").css('opacity','0.5');
            // jQuery(".curwinddeg").html("-");
            // jQuery(".curwinddir").html("--");
            // return;
        // }
    // }
    // jQuery(".arrow").css("visibility", "visible");
    //jQuery(".arrow").css('opacity','');
    weiherhammer_debug("rotateWindDir: rotating to " + newRotation);
    var currentRotation;
    finalRotation = finalRotation || 0; // if finalRotation undefined or 0, make 0, else finalRotation
    currentRotation = finalRotation % 360;
    if (currentRotation < 0) {currentRotation += 360;}
    if (currentRotation < 180 && (newRotation > (currentRotation + 180))) {finalRotation -= 360;}
    if (currentRotation >= 180 && (newRotation <= (currentRotation - 180))) {finalRotation += 360;}
    finalRotation += (newRotation - currentRotation);
    jQuery(".wind-arrow").css("transform", "rotate(" + finalRotation + "deg)");
    jQuery(".arrow").css("transform", "rotate(" + finalRotation + "deg)");
}

// Title case strings. https://stackoverflow.com/a/45253072/1177153
function titleCase(str) {
    return str.toLowerCase().split(' ').map(function(word) {
        return word.replace(word[0], word[0].toUpperCase());
    }).join(' ');
}

function autoTheme(sunset_hour, sunset_min, sunrise_hour, sunrise_min) {
    // First check if ?theme= is in URL. If so, bail out and do not change anything. 
    if (getURLvar("theme") && getURLvar("theme") != "auto") {
        weiherhammer_debug("Auto theme: theme override detected in URL. Skipping auto theme");
        return true;
    }
    weiherhammer_debug("Auto theme: checking to see if theme needs to be switched");

    var d = new Date();
    var nowHour = d.getHours();
    var nowMinutes = d.getMinutes();
    nowHour = nowHour;
    sunrise_hour = sunrise_hour;
    sunset_hour = sunset_hour;

    // Determine if it's day time. https://stackoverflow.com/a/14718577/1177153
    if (sunrise_hour <= nowHour && nowHour < sunset_hour) {
        dayTime = true;
    } else {
        dayTime = false;
    }

    weiherhammer_debug("Auto theme: sunrise: " + sunrise_hour);
    weiherhammer_debug("Auto theme: now: " + nowHour);
    weiherhammer_debug("Auto theme: sunset: " + sunset_hour);
    weiherhammer_debug("Auto theme: are we in daylight hours: " + dayTime);
    weiherhammer_debug("Auto theme: sessionStorage.getItem('theme') = " + sessionStorage.getItem('theme'));

    if (dayTime == true) {
        // Day time, set light if needed
        // Only change theme if user has not overridden the auto option with the toggle
        if (sessionStorage.getItem('theme') == "auto") {
            weiherhammer_debug("Auto theme: setting light theme since dayTime variable is true (day)");
            changeTheme("light");
        } else {
            weiherhammer_debug("Auto theme: cannot set light theme since visitor used toggle to override theme. Refresh to reset the override.");
        }
    } else {
        // Night time, set dark if needed
        // Only change theme if user has not overridden the auto option with the toggle
        if (sessionStorage.getItem('theme') == "auto") {
            weiherhammer_debug("Auto theme: setting dark theme since dayTime variable is false (night)");
            changeTheme("dark");
        } else {
            weiherhammer_debug("Auto theme: cannot set dark theme since visitor used toggle to override theme. Refresh to reset the override.");
        }
    }
}

function changeTheme(themeName, toggleOverride = false) {
    weiherhammer_debug("Theme: Changing to " + themeName);
    // If the configured theme is auto, but the user toggles light/dark, remove the auto option.
    if (toggleOverride) {
        weiherhammer_debug("Theme: toggle override clicked.");
        weiherhammer_debug("Theme: sessionStorage.getItem('theme') was previously: " + sessionStorage.getItem('theme'));
        // This was applied only to auto theme config, but now it's applied to all themes so visitor has full control on light/dark mode
        //if ( sessionStorage.getItem('theme') == "auto" ) { }
        sessionStorage.setItem('theme', 'toggleOverride');
        weiherhammer_debug("Theme: sessionStorage.getItem('theme') is now: " + sessionStorage.getItem('theme'));
    }
    if (themeName == "dark") {
        // Apply dark theme
        #if $radar_html_dark != "None"
        jQuery('.radar_image').html('$radar_html_dark');
        #end if
        jQuery('body').addClass("dark");
        jQuery('body').removeClass("light");
        #if $Extras.has_key('theme_toggle_enabled') and $Extras.theme_toggle_enabled == '1'
        jQuery("#themeSwitch").prop("checked", true);
        #end if
        #if $Extras.has_key('logo_image_dark') and $Extras.logo_image_dark != ""
        weiherhammer_debug("Theme: logo_image_dark is defined.");
        jQuery("#logo_image").attr("src", get_relative_url() + "/images/$Extras.logo_image_dark");
        #end if
        sessionStorage.setItem('currentTheme', 'dark');
    } else if (themeName == "light") {
        // Apply light theme
        #if $radar_html != "None"
        jQuery('.radar_image').html('$radar_html');
        #end if
        jQuery('body').addClass("light");
        jQuery('body').removeClass("dark");
        #if $Extras.has_key('theme_toggle_enabled') and $Extras.theme_toggle_enabled == '1'
        jQuery("#themeSwitch").prop("checked", false);
        #end if
        #if $Extras.has_key('logo_image') and $Extras.logo_image != ""
        weiherhammer_debug("Theme: logo_image is defined.");
        jQuery("#logo_image").attr("src", get_relative_url() + "/images/$Extras.logo_image");
        #end if
        sessionStorage.setItem('currentTheme', 'light');
    }
}

#if $Extras.has_key("forecast_enabled") and $Extras.forecast_enabled == '1'
#if $Extras.has_key('current_provider_toggle') and $Extras.current_provider_toggle == '1'
function changeCurrentProviderRadio(current_provider, toggleOverride = false) {
    weiherhammer_debug("changeCurrentProviderRadio: Changing to: " + current_provider);
    sessionStorage.setItem('current_provider', current_provider);
    if (toggleOverride) {
        sessionStorage.setItem('current_provider_override', 'toggleOverride');
    }
    jQuery("#provider_radio_" + current_provider).prop("checked", true);
    ajaxforecast(["current"]); // update current provider data
}
#end if
#end if


async function ajaxweewx() {
    resp = await fetch(get_relative_url() + "/json/weewx_data.json");
    if (!resp.ok) {
        throw new Error("HTTP error! Unable to load weewx_data.json");
    } else {
        return await resp.json();
    }
}

// Update with weewx data elements
//var station_obs_array = "";
var weewx_data = {};
var unit_rounding_array = {};
var unit_label_array = {};
var unit_group_array = {};
var vdp_array = {};
var external_forecast_available = "$external_forecast_available";
var builtin_forecast_available = "$builtin_forecast_available";

// Update data after refresh time only if MQTT not enabled
function update_with_weewx_data(data, data_update=false) {
    weiherhammer_debug("Updating with weewx data");
    weewx_data = data;

    // to prevent index errors
    if (!data.hasOwnProperty("extras")) {
        data["extras"] = {};
    }
    if (!data.hasOwnProperty("current")) {
        data["current"] = {};
    }
    if (!data.hasOwnProperty("day")) {
        data["day"] = {};
    }
    if (!data.hasOwnProperty("month")) {
        data["month"] = {};
    }
    if (!data.hasOwnProperty("week")) {
        data["week"] = {};
    }
    if (!data.hasOwnProperty("year")) {
        data["year"] = {};
    }
    if (!data.hasOwnProperty("raw")) {
        data["raw"] = {};
    }
    if (!data.hasOwnProperty("trend")) {
        data["trend"] = {};
    }
    if (!data.hasOwnProperty("roomclimate_extension_config")) {
        data["roomclimate_extension_config"] = {};
    }
    if (!data.hasOwnProperty("value_dependent_properties")) {
        data["value_dependent_properties"] = {};
    }

    //station_obs_array = data["station_observations"];
    try {
        unit_rounding_array = data["unit_rounding"];
        unit_label_array = data["unit_label"];
        unit_group_array = data["unit_group"];
        vdp_array = data["value_dependent_properties"];
    } catch (err) {
        // Returned "current" data does not have this value
        console.error("Error update_with_weewx_data", err);
    }

    // update only data values
    if (pageName == "homepage" && data_update) {
        // all obs with class = obs or class = obs_formatted
        try {
            jQuery.each(data["raw"], function(data_class, data_raw) {
                if (!unit_rounding_array.hasOwnProperty(data_class)) {
                    unit_rounding_array[data_class] = unit_rounding_array["default"]
                }
                if (!unit_label_array.hasOwnProperty(data_class)) {
                    unit_label_array[data_class] = unit_label_array["default"]
                }
                if (jQuery('.' + data_class).length > 0) {
                    // general (class = obs)
                    jQuery("." + data_class).html(parseFloat(parseFloat(data_raw)).toLocaleString("$system_locale_js", {minimumFractionDigits: unit_rounding_array[data_class], maximumFractionDigits: unit_rounding_array[data_class]}) + unit_label_array[data_class]);
                }
                if (jQuery('.' + data_class + "_formatted").length > 0) {
                    // obs_formatted
                    jQuery("." + data_class + "_formatted").html(parseFloat(parseFloat(data_raw)).toLocaleString("$system_locale_js", {minimumFractionDigits: unit_rounding_array[data_class], maximumFractionDigits: unit_rounding_array[data_class]}));
                }
            });
        } catch (err) {
            console.error("Error update_with_weewx_data", err);
        }

        try {
            // temperature observations
            jQuery(".day_outtemp_min").html(data["day"]["outTemp"]["min"]);
            jQuery(".day_outtemp_max").html(data["day"]["outTemp"]["max"]);

            // wind observations
            jQuery(".curwinddir").html(data["current"]["windDirCompass"]);
            jQuery(".curwinddeg").html(data["current"]["windDir"]);
            jQuery(".day_windrun_sum").html(data["day"]["wind"]["windrun_sum"]);

            // Daily Snapshot Stats Section
            jQuery(".day_wind_avg").html(data["day"]["wind"]["average"]);
            jQuery(".day_wind_max").html(data["day"]["wind"]["max"]);
            jQuery(".day_rainRate_max").html(data["day"]["rain"]["max"]);
            jQuery(".day_barometer_min").html(data["day"]["barometer"]["min"]);
            jQuery(".day_barometer_max").html(data["day"]["barometer"]["max"]);

            // Month Snapshot Stats Section
            jQuery(".month_outTemp_min").html(data["month"]["outTemp"]["min"]);
            jQuery(".month_outTemp_max").html(data["month"]["outTemp"]["max"]);
            jQuery(".month_wind_avg").html(data["month"]["wind"]["average"]);
            jQuery(".month_wind_max").html(data["month"]["wind"]["max"]);
            jQuery(".month_rainRate_max").html(data["month"]["rain"]["max"]);
            jQuery(".month_barometer_min").html(data["month"]["barometer"]["min"]);
            jQuery(".month_barometer_max").html(data["month"]["barometer"]["max"]);

        } catch (err) {
            // Returned data does not have this value
            console.error("Error update_with_weewx_data", err);
        }
    }

    if (pageName == "homepage") {
        try {
            // Update alerts and current data
            #if $Extras.has_key("forecast_enabled") and $Extras.forecast_enabled == '1'
            ajaxforecast(["alerts","current"]); 
            #end if

            // temperature observations
            jQuery(".day_outTemp_min").prop("title", "$obs.label.summaries_date_ttt" + data["day"]["outTemp"]["mintime"]);
            jQuery(".day_outTemp_max").prop("title", "$obs.label.summaries_date_ttt" + data["day"]["outTemp"]["maxtime"]);

            // wind observations
            rotateWindDir(data["current"]["windDir_formatted"], data["raw"]["windSpeed"]);

            // Daily Snapshot Stats Section
            jQuery(".summaries-day-title").html(tzAdjustedMoment(data["current"]["epoch"]).format('$obs.label.time_summaries_day_title'));
            jQuery(".summaries-month-title").html(tzAdjustedMoment(data["current"]["epoch"]).format('$obs.label.time_summaries_month_title'));

            // Daily Snapshot Stats Section Tooltip
            jQuery(".day_wind_max").prop("title", "$obs.label.summaries_date_ttt" + data["day"]["wind"]["maxtime"]);
            jQuery(".day_rainRate_max").prop("title", "$obs.label.summaries_date_ttt" + data["day"]["rain"]["maxtime"]);
            jQuery(".day_barometer_min").prop("title", "$obs.label.summaries_date_ttt" + data["day"]["barometer"]["mintime"]);
            jQuery(".day_barometer_max").prop("title", "$obs.label.summaries_date_ttt" + data["day"]["barometer"]["maxtime"]);

            // Month Snapshot Stats Section Tooltip
            jQuery(".month_outTemp_min").prop("title", "$obs.label.summaries_date_ttt" + data["month"]["outTemp"]["mintime"]);
            jQuery(".month_outTemp_max").prop("title", "$obs.label.summaries_date_ttt" + data["month"]["outTemp"]["maxtime"]);
            jQuery(".month_wind_max").prop("title", "$obs.label.summaries_date_ttt" + data["month"]["wind"]["maxtime"]);
            jQuery(".month_rainRate_max").prop("title", "$obs.label.summaries_date_ttt" + data["month"]["rain"]["maxtime"]);
            jQuery(".month_barometer_min").prop("title", "$obs.label.summaries_date_ttt" + data["month"]["barometer"]["mintime"]);
            jQuery(".month_barometer_max").prop("title", "$obs.label.summaries_date_ttt" + data["month"]["barometer"]["maxtime"]);
        } catch (err) {
            // Returned data does not have this value
            console.error("Error update_with_weewx_data", err);
        }

        try {
            // Sunrise and Sunset
            jQuery(".sunrise-value").html(tzAdjustedMoment(parseFloat(data["almanac"]["sunrise_epoch"]).toFixed(0)).format("$obs.label.time_sunrise"));
            jQuery(".sunset-value").html(tzAdjustedMoment(parseFloat(data["almanac"]["sunset_epoch"]).toFixed(0)).format("$obs.label.time_sunset"));
            jQuery(".moonrise-value").html(tzAdjustedMoment(parseFloat(data["almanac"]["moon"]["moon_rise_epoch"]).toFixed(0)).format("$obs.label.time_sunrise"));
            jQuery(".moonset-value").html(tzAdjustedMoment(parseFloat(data["almanac"]["moon"]["moon_set_epoch"]).toFixed(0)).format("$obs.label.time_sunrise"));

            // Moon icon, phase and illumination percent
            jQuery(".moon-icon").html(moon_icon(data["almanac"]["moon"]["moon_index"]));
            jQuery(".moon-phase").html(titleCase(data["almanac"]["moon"]["moon_phase"])); // Javascript function above
            jQuery(".moon-visible").html("<strong>" + data["almanac"]["moon"]["moon_fullness"] + "%</strong> $obs.label.moon_visible");
        } catch (err) {
            // Returned data does not have this value
            console.error("Error update_with_weewx_data", err);
        }

        #if $almanac.hasExtras
        try {
            // Close current modal if open
            //jQuery('#almanac').modal('hide');
            jQuery(".almanac-extras-modal-body").html(data["almanac"]["almanac_extras_modal_html"]);
            almanac_updated = "$obs.label.header_last_updated " + tzAdjustedMoment(data["current"]["dateTime_raw"]).format("$obs.label.time_last_updated");
            jQuery(".almanac_last_updated").html(almanac_updated);
        } catch (err) {
            // Returned data does not have this value
            console.error("Error update_with_weewx_data", err);
        }
        #end if

        // ========================================================
        // obs value dependent properties if enabled
        // ========================================================

        #if $Extras.has_key("value_depended_properties_enabled") and $Extras.value_depended_properties_enabled == '1'

        // Temperature properties
        if (vdp_array.hasOwnProperty("station")) {
            if (vdp_array["station"].hasOwnProperty("obs")) {
                if (vdp_array["station"]["obs"].includes('outTemp')) {
                   get_outTemp_color("$unit.unit_type.outTemp", data["current"]["outTemp_formatted"]);
                }
            }
        }

        // aqi properties
        #if $Extras.has_key("aqi_enabled") and $Extras.aqi_enabled == '1'
        try {
            if (vdp_array.hasOwnProperty("aqi")) {
                if (vdp_array["aqi"].hasOwnProperty("obs")) {
                    var vals = vdp_array["aqi"]["obs"];
                    //console.log("aqi all obs", vals);
                    for (var i = 0; i < vals.length; i++) {
                        //console.log("aqi obs", vals[i]);
                        if (data["raw"].hasOwnProperty(vals[i])) {
                            update_aqi_properties(data, vals[i], data["raw"][vals[i]]);
                        }
                    }
                }
            }
        } catch (err) {
            // Returned data does not have this value
            console.error("Error update_with_weewx_data", err);
        }
        #end if

        // pressure trend properties
        try {
            if (vdp_array.hasOwnProperty("pressure_trend")) {
                if (vdp_array["pressure_trend"].hasOwnProperty("obs")) {
                    var vals = vdp_array["pressure_trend"]["obs"];
                    for (var i = 0; i < vals.length; i++) {
                        if (data["trend"].hasOwnProperty(vals[i])) {
                            if (data["trend"][vals[i]].hasOwnProperty("raw")) {
                                update_pressure_trend_properties(data, vals[i], data["trend"][vals[i]]["raw"]);
                            }
                        }
                    }
                }
            }
        } catch (err) {
            // Returned data does not have this value
            console.error("Error update_with_weewx_data", err);
        }

        // battery properties
        try {
            if (vdp_array.hasOwnProperty("batt")) {
                if (vdp_array["batt"].hasOwnProperty("obs")) {
                    var vals = vdp_array["batt"]["obs"];
                }
                if (vdp_array["batt"].hasOwnProperty("group")) {
                    var groups = vdp_array["batt"]["group"];
                }
                if (vals.length == groups.length) {
                    for (var i = 0; i < vals.length; i++) {
                        if (data["raw"].hasOwnProperty(vals[i])) {
                            update_battery_properties(data, vals[i], groups[i], data["raw"][vals[i]]);
                        }
                    }
                }
            }
        } catch (err) {
            // Returned data does not have this value
            console.error("Error update_with_weewx_data", err);
        }

        // voltage properties
        try {
            if (vdp_array.hasOwnProperty("voltage")) {
                if (vdp_array["voltage"].hasOwnProperty("obs")) {
                    var vals = vdp_array["voltage"]["obs"];
                }
                if (vdp_array["voltage"].hasOwnProperty("group")) {
                    var groups = vdp_array["voltage"]["group"];
                }
                if (vals.length == groups.length) {
                    for (var i = 0; i < vals.length; i++) {
                        if (data["raw"].hasOwnProperty(vals[i])) {
                            update_voltage_properties(data, vals[i], groups[i], data["raw"][vals[i]]);
                        }
                    }
                }
            }
        } catch (err) {
            // Returned data does not have this value
            console.error("Error update_with_weewx_data", err);
        }

        // signal properties
        try {
            if (vdp_array.hasOwnProperty("sig")) {
                if (vdp_array["sig"].hasOwnProperty("obs")) {
                    var vals = vdp_array["sig"]["obs"];
                    for (var i = 0; i < vals.length; i++) {
                        if (data["raw"].hasOwnProperty(vals[i])) {
                            update_signal_properties(data, vals[i], data["raw"][vals[i]]);
                        }
                    }
                }
            }
        } catch (err) {
            // Returned data does not have this value
            console.error("Error update_with_weewx_data", err);
        }

        // switch properties
        try {
            if (vdp_array.hasOwnProperty("switch")) {
                if (vdp_array["switch"].hasOwnProperty("obs")) {
                    var vals = vdp_array["switch"]["obs"];
                }
                if (vdp_array["switch"].hasOwnProperty("group")) {
                    var groups = vdp_array["switch"]["group"];
                }
                if (vals.length == groups.length) {
                    for (var i = 0; i < vals.length; i++) {
                        if (data["raw"].hasOwnProperty(vals[i])) {
                            update_switch_properties(data, vals[i], groups[i], data["raw"][vals[i]]);
                        }
                    }
                }
            }
        } catch (err) {
            // Returned data does not have this value
            console.error("Error update_with_weewx_data", err);
        }

        // room climate properties
        try {
            update_roomclimate_properties(data["raw"]);
        } catch (err) {
            // Returned data does not have this value
            console.error("Error update_with_weewx_data", err);
        }

        #end if
    }
}

//  function returns html for moon-icon according to moonphase value and currentTheme setting
function moon_icon(moonphase){
    
    var moon_icon_dict = {
        "0": "<div class='wi wi-moon-new'></div>",
        "1": "<div class='wi wi-moon-waxing-crescent-3 $hemisphere'></div>",
        "2": "<div class='wi wi-moon-first-quarter $hemisphere'></div>",
        "3": "<div class='wi wi-moon-waxing-gibbous-3 $hemisphere'></div>",
        "4": "<div class='wi wi-moon-full'></div>",
        "5": "<div class='wi wi-moon-waning-gibbous-3 $hemisphere'></div>",
        "6": "<div class='wi wi-moon-third-quarter $hemisphere'></div>",
        "7": "<div class='wi wi-moon-waning-crescent-4 $hemisphere'></div>",
    }
    
    var output = moon_icon_dict[moonphase];
    if (sessionStorage.getItem('currentTheme') === 'dark') {
        return output;
    } else {
        return output.replace('-moon-','-moon-alt-');
    }
}

#if $Extras.has_key("forecast_enabled") and $Extras.forecast_enabled == '1'
function ajaxforecast(options=['']) {
    //console.log("ajaxforecast", options);
    var forecast_external = {};
    var forecast_builtin = {};
    var weewx_dwd = {};
    jQuery.when(
        #if $external_forecast_available == "1"
        // Get the forecast from external calls
        jQuery.getJSON(get_relative_url() + "/json/forecast.json", function(forecast) {
            //console.log("forecast.json", forecast);
            forecast_external = forecast;
        }),
        #end if
        #if $builtin_forecast_available == "1"
        // Get the built in forecast
        jQuery.getJSON(get_relative_url() + "/json/forecast_builtin.json", function(forecast) {
            //console.log("forecast_builtin.json", forecast);
            forecast_builtin = forecast;
        }),
        #end if
        // Test
        jQuery.getJSON(get_relative_url() + "/json/weewx_dwd.json", function(forecast) {
            //console.log("weewx_dwd.json", forecast);
            weewx_dwd = forecast;
        }),
        // Get the iconlist - original source is // https://www.aerisweather.com/support/docs/api/reference/icon-list/
        jQuery.getJSON(get_relative_url() + '/images/aeris-icon-list.json', function(iconlist) {
        icon_dict = iconlist;
        })
    ).then(function() {
        // Merge external and builtin forecast
        forecast_data = Object.assign({}, forecast_external, forecast_builtin, weewx_dwd);
        //console.log("forecast_data", forecast_data);

        if (options == "none") {
            return true;
        }
        var cnt = options.length; // 0 = all but filter with pageName
        if (cnt == 0) {
            if (pageName == "homepage") {
                options = ["alerts", "current"];
            } else if (pageName == "forecast") {
                options = ["forecast"];
            } else {
                options = ["all"];
            }
        }
        for (var i = 0; i < options.length; i++) {
            //console.log("ajaxforecast options=" + options[i]);
            if (options[i] == "all" || options[i] == "current") {
                // update current weather data
                //console.log("update_current_data");
                update_current_data(forecast_data);
            }
            if (options[i] == "all" || options[i] == "alerts") {
                // update alerts data
                //console.log("update_alerts_data");
                update_alerts_data(forecast_data);
            }
            if (options[i] == "all" || options[i] == "aqi") {
                // update aqi data
                //console.log("update_aqi_data");
                update_aqi_data(forecast_data);
            }
            if (options[i] == "all" || options[i] == "forecast") {
                // update forecast once both promises are fulfilled
                //console.log("update_forecast_data");
                update_forecast_data(forecast_data);
                if (options[i] == "forecast") {
                    //console.log("update_current_data");
                    update_current_data(forecast_data, ["wxicon"]);
                }
            }
        }
    });
}

function aeris_coded_weather(data, full_observation = false) {
    // https://www.aerisweather.com/support/docs/api/reference/weather-codes/
    var output = "";
    var coverage_code = data.split(":")[0]
    var intensity_code = data.split(":")[1]
    var weather_code = data.split(":")[2]

    // console.log("Aeris Code: " + data);
    // console.log("Coverage Code: " + coverage_code);
    // console.log("Intensity Code: " + intensity_code);
    // console.log("Weather Code: " + weather_code);

    var cloud_dict = {
        "CL": "$obs.label.forecast_cloud_code_CL",
        "FW": "$obs.label.forecast_cloud_code_FW",
        "SC": "$obs.label.forecast_cloud_code_SC",
        "BK": "$obs.label.forecast_cloud_code_BK",
        "OV": "$obs.label.forecast_cloud_code_OV"
    }

    var coverage_dict = {
        "AR": "$obs.label.forecast_coverage_code_AR",
        "BR": "$obs.label.forecast_coverage_code_BR",
        "C": "$obs.label.forecast_coverage_code_C",
        "D": "$obs.label.forecast_coverage_code_D",
        "FQ": "$obs.label.forecast_coverage_code_FQ",
        "IN": "$obs.label.forecast_coverage_code_IN",
        "IS": "$obs.label.forecast_coverage_code_IS",
        "L": "$obs.label.forecast_coverage_code_L",
        "NM": "$obs.label.forecast_coverage_code_NM",
        "O": "$obs.label.forecast_coverage_code_O",
        "PA": "$obs.label.forecast_coverage_code_PA",
        "PD": "$obs.label.forecast_coverage_code_PD",
        "S": "$obs.label.forecast_coverage_code_S",
        "SC": "$obs.label.forecast_coverage_code_SC",
        "VC": "$obs.label.forecast_coverage_code_VC",
        "WD": "$obs.label.forecast_coverage_code_WD"
    }

    var intensity_dict = {
        "VL": "$obs.label.forecast_intensity_code_VL",
        "L": "$obs.label.forecast_intensity_code_L",
        "H": "$obs.label.forecast_intensity_code_H",
        "VH": "$obs.label.forecast_intensity_code_VH"
    }

    var weather_dict = {
        "A": "$obs.label.forecast_weather_code_A",
        "BD": "$obs.label.forecast_weather_code_BD",
        "BN": "$obs.label.forecast_weather_code_BN",
        "BR": "$obs.label.forecast_weather_code_BR",
        "BS": "$obs.label.forecast_weather_code_BS",
        "BY": "$obs.label.forecast_weather_code_BY",
        "F": "$obs.label.forecast_weather_code_F",
        "FR": "$obs.label.forecast_weather_code_FR",
        "H": "$obs.label.forecast_weather_code_H",
        "IC": "$obs.label.forecast_weather_code_IC",
        "IF": "$obs.label.forecast_weather_code_IF",
        "IP": "$obs.label.forecast_weather_code_IP",
        "K": "$obs.label.forecast_weather_code_K",
        "L": "$obs.label.forecast_weather_code_L",
        "R": "$obs.label.forecast_weather_code_R",
        "RW": "$obs.label.forecast_weather_code_RW",
        "RS": "$obs.label.forecast_weather_code_RS",
        "SI": "$obs.label.forecast_weather_code_SI",
        "WM": "$obs.label.forecast_weather_code_WM",
        "S": "$obs.label.forecast_weather_code_S",
        "SW": "$obs.label.forecast_weather_code_SW",
        "T": "$obs.label.forecast_weather_code_T",
        "UP": "$obs.label.forecast_weather_code_UP",
        "VA": "$obs.label.forecast_weather_code_VA",
        "WP": "$obs.label.forecast_weather_code_WP",
        "ZF": "$obs.label.forecast_weather_code_ZF",
        "ZL": "$obs.label.forecast_weather_code_ZL",
        "ZR": "$obs.label.forecast_weather_code_ZR",
        "ZY": "$obs.label.forecast_weather_code_ZY"
    }

    // Check if the weather_code is in the cloud_dict and use that if it's there. If not then it's a combined weather code.
    if (cloud_dict.hasOwnProperty(weather_code)) {
        return cloud_dict[weather_code];
    } else {
        // Add the coverage if it's present, and full observation forecast is requested
        if ((coverage_code) && (full_observation) && coverage_dict.hasOwnProperty(coverage_code)) {
            output += coverage_dict[coverage_code] + " ";
        }
        // Add the intensity if it's present
        if (intensity_code && intensity_dict.hasOwnProperty(intensity_code)) {
            output += intensity_dict[intensity_code] + " ";
        }
        // Weather output
        if (weather_dict.hasOwnProperty(weather_code)) {
            output += weather_dict[weather_code];
        }
    }

    if (output == "") {
        output = "$gettext('unknown')";
    }
    // console.log("Result: " + output);

    return output;
}

function aeris_coded_alerts(data, full_observation = false) {
    // https://www.aerisweather.com/support/docs/aeris-maps/reference/alert-types/

    var alert_dict = {
        "TOE": "$obs.label.forecast_alert_code_TOE",
        "ADR": "$obs.label.forecast_alert_code_ADR",
        "AQA": "$obs.label.forecast_alert_code_AQA",
        "AQ.S": "$obs.label.forecast_alert_code_AQ_S",
        "AS.Y": "$obs.label.forecast_alert_code_AS_Y",
        "AR.W": "$obs.label.forecast_alert_code_AR_W",
        "AF.Y": "$obs.label.forecast_alert_code_AF_Y",
        "MH.Y": "$obs.label.forecast_alert_code_MH_Y",
        "AF.W": "$obs.label.forecast_alert_code_AF_W",
        "AVW": "$obs.label.forecast_alert_code_AVW",
        "AVA": "$obs.label.forecast_alert_code_AVA",
        "BH.S": "$obs.label.forecast_alert_code_BH_S",
        "BZ.W": "$obs.label.forecast_alert_code_BZ_W",
        "DU.Y": "$obs.label.forecast_alert_code_DU_Y",
        "BS.Y": "$obs.label.forecast_alert_code_BS_Y",
        "BW.Y": "$obs.label.forecast_alert_code_BW_Y",
        "CAE": "$obs.label.forecast_alert_code_CAE",
        "CDW": "$obs.label.forecast_alert_code_CDW",
        "CEM": "$obs.label.forecast_alert_code_CEM",
        "CF.Y": "$obs.label.forecast_alert_code_CF_Y",
        "CF.S": "$obs.label.forecast_alert_code_CF_S",
        "CF.W": "$obs.label.forecast_alert_code_CF_W",
        "CF.A": "$obs.label.forecast_alert_code_CF_A",
        "FG.Y": "$obs.label.forecast_alert_code_FG_Y",
        "MF.Y": "$obs.label.forecast_alert_code_MF_Y",
        "FO.Y": "$obs.label.forecast_alert_code_FO_Y",
        "SM.Y": "$obs.label.forecast_alert_code_SM_Y",
        "MS.Y": "$obs.label.forecast_alert_code_MS_Y",
        "DS.W": "$obs.label.forecast_alert_code_DS_W",
        "EQW": "$obs.label.forecast_alert_code_EQW",
        "EVI": "$obs.label.forecast_alert_code_EVI",
        "EH.W": "$obs.label.forecast_alert_code_EH_W",
        "EH.A": "$obs.label.forecast_alert_code_EH_A",
        "EC.W": "$obs.label.forecast_alert_code_EC_W",
        "EC.A": "$obs.label.forecast_alert_code_EC_A",
        "RFD": "$obs.label.forecast_alert_code_RFD",
        "EW.W": "$obs.label.forecast_alert_code_EW_W",
        "FRW": "$obs.label.forecast_alert_code_FRW",
        "FW.A": "$obs.label.forecast_alert_code_FW_A",
        "FF.S": "$obs.label.forecast_alert_code_FF_S",
        "FF.W": "$obs.label.forecast_alert_code_FF_W",
        "FF.A": "$obs.label.forecast_alert_code_FF_A",
        "FE.W": "$obs.label.forecast_alert_code_FE_W",
        "FL.Y": "$obs.label.forecast_alert_code_FL_Y",
        "FL.S": "$obs.label.forecast_alert_code_FL_S",
        "FL.W": "$obs.label.forecast_alert_code_FL_W",
        "FA.W": "$obs.label.forecast_alert_code_FA_W",
        "FL.A": "$obs.label.forecast_alert_code_FL_A",
        "FA.A": "$obs.label.forecast_alert_code_FA_A",
        "FZ.W": "$obs.label.forecast_alert_code_FZ_W",
        "FZ.A": "$obs.label.forecast_alert_code_FZ_A",
        "ZL.Y": "$obs.label.forecast_alert_code_ZL_Y",
        "ZF.Y": "$obs.label.forecast_alert_code_ZF_Y",
        "ZR.W": "$obs.label.forecast_alert_code_ZR_W",
        "UP.Y": "$obs.label.forecast_alert_code_UP_Y",
        "FR.Y": "$obs.label.forecast_alert_code_FR_Y",
        "GL.W": "$obs.label.forecast_alert_code_GL_W",
        "GL.A": "$obs.label.forecast_alert_code_GL_A",
        "HZ.W": "$obs.label.forecast_alert_code_HZ_W",
        "HZ.A": "$obs.label.forecast_alert_code_HZ_A",
        "HMW": "$obs.label.forecast_alert_code_HMW",
        "SE.W": "$obs.label.forecast_alert_code_SE_W",
        "SE.A": "$obs.label.forecast_alert_code_SE_A",
        "HWO": "$obs.label.forecast_alert_code_HWO",
        "HT.Y": "$obs.label.forecast_alert_code_HT_Y",
        "HT.W": "$obs.label.forecast_alert_code_HT_W",
        "UP.W": "$obs.label.forecast_alert_code_UP_W",
        "UP.A": "$obs.label.forecast_alert_code_UP_A",
        "SU.Y": "$obs.label.forecast_alert_code_SU_Y",
        "SU.W": "$obs.label.forecast_alert_code_SU_W",
        "HW.W": "$obs.label.forecast_alert_code_HW_W",
        "HW.A": "$obs.label.forecast_alert_code_HW_A",
        "HF.W": "$obs.label.forecast_alert_code_HF_W",
        "HF.A": "$obs.label.forecast_alert_code_HF_A",
        "HU.S": "$obs.label.forecast_alert_code_HU_S",
        "HU.W": "$obs.label.forecast_alert_code_HU_W",
        "HU.A": "$obs.label.forecast_alert_code_HU_A",
        "FA.Y": "$obs.label.forecast_alert_code_FA_Y",
        "IS.W": "$obs.label.forecast_alert_code_IS_W",
        "LE.W": "$obs.label.forecast_alert_code_LE_W",
        "LW.Y": "$obs.label.forecast_alert_code_LW_Y",
        "LS.Y": "$obs.label.forecast_alert_code_LS_Y",
        "LS.S": "$obs.label.forecast_alert_code_LS_S",
        "LS.W": "$obs.label.forecast_alert_code_LS_W",
        "LS.A": "$obs.label.forecast_alert_code_LS_A",
        "LEW": "$obs.label.forecast_alert_code_LEW",
        "LAE": "$obs.label.forecast_alert_code_LAE",
        "LO.Y": "$obs.label.forecast_alert_code_LO_Y",
        "MA.S": "$obs.label.forecast_alert_code_MA_S",
        "NUW": "$obs.label.forecast_alert_code_NUW",
        "RHW": "$obs.label.forecast_alert_code_RHW",
        "RA.W": "$obs.label.forecast_alert_code_RA_W",
        "FW.W": "$obs.label.forecast_alert_code_FW_W",
        "RFW": "$obs.label.forecast_alert_code_RFW",
        "RP.S": "$obs.label.forecast_alert_code_RP_S",
        "SV.W": "$obs.label.forecast_alert_code_SV_W",
        "SV.A": "$obs.label.forecast_alert_code_SV_A",
        "SV.S": "$obs.label.forecast_alert_code_SV_S",
        "TO.S": "$obs.label.forecast_alert_code_TO_S",
        "SPW": "$obs.label.forecast_alert_code_SPW",
        "NOW": "$obs.label.forecast_alert_code_NOW",
        "SC.Y": "$obs.label.forecast_alert_code_SC_Y",
        "SW.Y": "$obs.label.forecast_alert_code_SW_Y",
        "RB.Y": "$obs.label.forecast_alert_code_RB_Y",
        "SI.Y": "$obs.label.forecast_alert_code_SI_Y",
        "SO.W": "$obs.label.forecast_alert_code_SO_W",
        "SQ.W": "$obs.label.forecast_alert_code_SQ_W",
        "SQ.A": "$obs.label.forecast_alert_code_SQ_A",
        "SB.Y": "$obs.label.forecast_alert_code_SB_Y",
        "SN.W": "$obs.label.forecast_alert_code_SN_W",
        "MA.W": "$obs.label.forecast_alert_code_MA_W",
        "SP.S": "$obs.label.forecast_alert_code_SPS",
        "SG.W": "$obs.label.forecast_alert_code_SG_W",
        "SS.W": "$obs.label.forecast_alert_code_SS_W",
        "SS.A": "$obs.label.forecast_alert_code_SS_A",
        "SR.W": "$obs.label.forecast_alert_code_SR_W",
        "SR.A": "$obs.label.forecast_alert_code_SR_A",
        "TO.W": "$obs.label.forecast_alert_code_TO_W",
        "TO.A": "$obs.label.forecast_alert_code_TO_A",
        "TC.S": "$obs.label.forecast_alert_code_TC_S",
        "TR.S": "$obs.label.forecast_alert_code_TR_S",
        "TR.W": "$obs.label.forecast_alert_code_TR_W",
        "TR.A": "$obs.label.forecast_alert_code_TR_A",
        "TS.Y": "$obs.label.forecast_alert_code_TS_Y",
        "TS.W": "$obs.label.forecast_alert_code_TS_W",
        "TS.A": "$obs.label.forecast_alert_code_TS_A",
        "TY.S": "$obs.label.forecast_alert_code_TY_S",
        "TY.W": "$obs.label.forecast_alert_code_TY_W",
        "TY.A": "$obs.label.forecast_alert_code_TY_A",
        "VOW": "$obs.label.forecast_alert_code_VOW",
        "WX.Y": "$obs.label.forecast_alert_code_WX_Y",
        "WX.W": "$obs.label.forecast_alert_code_WX_W",
        "WI.Y": "$obs.label.forecast_alert_code_WI_Y",
        "WC.Y": "$obs.label.forecast_alert_code_WC_Y",
        "WC.W": "$obs.label.forecast_alert_code_WC_W",
        "WC.A": "$obs.label.forecast_alert_code_WC_A",
        "WI.W": "$obs.label.forecast_alert_code_WI_W",
        "WS.W": "$obs.label.forecast_alert_code_WS_W",
        "WS.A": "$obs.label.forecast_alert_code_WS_A",
        "LE.A": "$obs.label.forecast_alert_code_LE_A",
        "BZ.A": "$obs.label.forecast_alert_code_BZ_A",
        "WW.Y": "$obs.label.forecast_alert_code_WW_Y",
        "LE.Y": "$obs.label.forecast_alert_code_LE_Y",
        "ZR.Y": "$obs.label.forecast_alert_code_ZR_Y",
        "AW.WI.MN": "$obs.label.forecast_alert_code_AW_WI_MN",
        "AW.WI.MD": "$obs.label.forecast_alert_code_AW_WI_MD",
        "AW.WI.SV": "$obs.label.forecast_alert_code_AW_WI_SV",
        "AW.WI.EX": "$obs.label.forecast_alert_code_AW_WI_EX",
        "AW.SI.MN": "$obs.label.forecast_alert_code_AW_SI_MN",
        "AW.SI.MD": "$obs.label.forecast_alert_code_AW_SI_MD",
        "AW.SI.SV": "$obs.label.forecast_alert_code_AW_SI_SV",
        "AW.SI.EX": "$obs.label.forecast_alert_code_AW_SI_EX",
        "AW.TS.MN": "$obs.label.forecast_alert_code_AW_TS_MN",
        "AW.TS.MD": "$obs.label.forecast_alert_code_AW_TS_MD",
        "AW.TS.SV": "$obs.label.forecast_alert_code_AW_TS_SV",
        "AW.TS.EX": "$obs.label.forecast_alert_code_AW_TS_EX",
        "AW.LI.MN": "$obs.label.forecast_alert_code_AW_LI_MN",
        "AW.LI.MD": "$obs.label.forecast_alert_code_AW_LI_MD",
        "AW.LI.SV": "$obs.label.forecast_alert_code_AW_LI_SV",
        "AW.LI.EX": "$obs.label.forecast_alert_code_AW_LI_EX",
        "AW.FG.MN": "$obs.label.forecast_alert_code_AW_FG_MN",
        "AW.FG.MD": "$obs.label.forecast_alert_code_AW_FG_MD",
        "AW.FG.SV": "$obs.label.forecast_alert_code_AW_FG_SV",
        "AW.FG.EX": "$obs.label.forecast_alert_code_AW_FG_EX",
        "AW.HT.MN": "$obs.label.forecast_alert_code_AW_HT_MN",
        "AW.HT.MD": "$obs.label.forecast_alert_code_AW_HT_MD",
        "AW.HT.SV": "$obs.label.forecast_alert_code_AW_HT_SV",
        "AW.HT.EX": "$obs.label.forecast_alert_code_AW_HT_EX",
        "AW.LT.MN": "$obs.label.forecast_alert_code_AW_LT_MN",
        "AW.LT.MD": "$obs.label.forecast_alert_code_AW_LT_MD",
        "AW.LT.SV": "$obs.label.forecast_alert_code_AW_LT_SV",
        "AW.LT.EX": "$obs.label.forecast_alert_code_AW_LT_EX",
        "AW.CE.MN": "$obs.label.forecast_alert_code_AW_CE_MN",
        "AW.CE.MD": "$obs.label.forecast_alert_code_AW_CE_MD",
        "AW.CE.SV": "$obs.label.forecast_alert_code_AW_CE_SV",
        "AW.CE.EX": "$obs.label.forecast_alert_code_AW_CE_EX",
        "AW.FR.MN": "$obs.label.forecast_alert_code_AW_FR_MN",
        "AW.FR.MD": "$obs.label.forecast_alert_code_AW_FR_MD",
        "AW.FR.SV": "$obs.label.forecast_alert_code_AW_FR_SV",
        "AW.FR.EX": "$obs.label.forecast_alert_code_AW_FR_EX",
        "AW.AV.MN": "$obs.label.forecast_alert_code_AW_AV_MN",
        "AW.AV.MD": "$obs.label.forecast_alert_code_AW_AV_MD",
        "AW.AV.SV": "$obs.label.forecast_alert_code_AW_AV_SV",
        "AW.AV.EX": "$obs.label.forecast_alert_code_AW_AV_EX",
        "AW.RA.MN": "$obs.label.forecast_alert_code_AW_RA_MN",
        "AW.RA.MD": "$obs.label.forecast_alert_code_AW_RA_MD",
        "AW.RA.SV": "$obs.label.forecast_alert_code_AW_RA_SV",
        "AW.RA.EX": "$obs.label.forecast_alert_code_AW_RA_EX",
        "AW.FL.MN": "$obs.label.forecast_alert_code_AW_FL_MN",
        "AW.FL.MD": "$obs.label.forecast_alert_code_AW_FL_MD",
        "AW.FL.SV": "$obs.label.forecast_alert_code_AW_FL_SV",
        "AW.FL.EX": "$obs.label.forecast_alert_code_AW_FL_EX",
        "AW.RF.MN": "$obs.label.forecast_alert_code_AW_RF_MN",
        "AW.RF.MD": "$obs.label.forecast_alert_code_AW_RF_MD",
        "AW.RF.SV": "$obs.label.forecast_alert_code_AW_RF_SV",
        "AW.RF.EX": "$obs.label.forecast_alert_code_AW_RF_EX",
        "AW.UK.MN": "$obs.label.forecast_alert_code_AW_UK_MN",
        "AW.UK.MD": "$obs.label.forecast_alert_code_AW_UK_MD",
        "AW.UK.SV": "$obs.label.forecast_alert_code_AW_UK_SV",
        "AW.UK.EX": "$obs.label.forecast_alert_code_AW_UK_EX"
    }
    
    if (alert_dict.hasOwnProperty(data)) {
        return alert_dict[data];
    } else {
        return "$gettext('unknown')"
    }
}

function aeris_icon(data) {
    // https://www.aerisweather.com/support/docs/api/reference/icon-list/
    var icon_name = data.split(".")[0]; // Remove .png
    if (icon_dict.hasOwnProperty(icon_name)) {
        return icon_dict[icon_name]
    } else {
        //return "unknown"
        //TODO?
        return icon_name
    }
}

function aeris_aqi_translate(data) {
    if (data === "good") data = "$obs.label.aqi_good";
    else if (data === "moderate") data = "$obs.label.aqi_moderate";
    else if (data === "usg") data = "$obs.label.aqi_usg";
    else if (data === "unhealthy") data = "$obs.label.aqi_unhealthy";
    else if (data === "very unhealthy") data = "$obs.label.aqi_very_unhealthy";
    else if (data === "hazardous") data = "$obs.label.aqi_hazardous";
    else data = "$gettext('unknown')";

    return data;
}

function update_aqi_data(data) {
    //TODO
/* TODO
        // AQI
        if (data["aqi"][0]["success"] && !data["aqi"][0]["error"]) {
            jQuery(".wx-aqi").html(data["aqi"][0]["response"][0]["periods"][0]["aqi"]);
            jQuery(".wx-aqi-category").html(aeris_aqi_translate(data["aqi"][0]["response"][0]["periods"][0]["category"]));
            if ("$Extras.aqi_location_enabled" === "1") jQuery(".aqi_location_outer").html("<br>" + '$obs.label.aqi_source, ' + data["aqi"][0]["response"][0]["place"]["name"]).css('textTransform', 'capitalize');
            get_aqi_color(data["aqi"][0]["response"][0]["periods"][0]["aqi"]);
            try {
                jQuery(".station-observations .aqi").html(data["aqi"][0]["response"][0]["periods"][0]["aqi"]);
            } catch (err) {
                // AQI not in the station observation table, so silently exit
            }
        } else if (data["aqi"][0]["success"] && data["aqi"][0]["error"]["code"] === "warn_no_data") {
            jQuery(".wx-aqi").html("No Data");
            jQuery(".wx-aqi-category").html(aeris_aqi_translate(""));
            if ("$Extras.aqi_location_enabled" === "1") jQuery(".aqi_location_outer").html("");
            try {
                jQuery(".station-observations .aqi").html("No Data");
            } catch (err) {
                // AQI not in the station observation table, so silently exit
            }
        }
*/
}

function update_alerts_data(data) {
    var alerts_provider = "$alerts_provider";
    weiherhammer_debug("Current: Provider is " + alerts_provider);
    weiherhammer_debug("Current: Updating data");
    weiherhammer_debug(data);

    try {
        if (!data.hasOwnProperty(alerts_provider)) {
            throw new Error("Forecast JSON file does not contain alerts data for provider=" + alerts_provider);
        } else if (!data[alerts_provider].hasOwnProperty("alerts")) {
            throw new Error("Forecast JSON file does not contain alerts data. Provider=" + alerts_provider);
        }

        //TODO more checks?

        // using data from alerts provider
        data = data[alerts_provider];

        var i, forecast_alert_modal, forecast_alerts;
        forecast_alert_modal = "";
        forecast_alerts = [];

        // Empty anything that's been appended to the modal from the previous run
        jQuery(".wx-stn-alert-text").empty();

        if (alerts_provider == "darksky") {
            if (data['alerts']) {
                for (i = 0; i < data['alerts'].length; i++) {
                    forecast_alert_title = data['alerts'][i]['title'];
                    forecast_alert_body = data['alerts'][i]['description'].replace(/\n/g, '<br>');
                    forecast_alert_link = data['alerts'][i]['title'];
                    forecast_alert_expires = tzAdjustedMoment(data['alerts'][i]['expires']).format('$obs.label.time_forecast_alert_expires');
                    forecast_alerts.push({"title": forecast_alert_title, "body": forecast_alert_body, "link": forecast_alert_link, "expires": forecast_alert_expires});
                }
            }
        } else {
            if (data['alerts'][0]['response'][0]) {
                for (i = 0; i < data['alerts'][0]['response'].length; i++) {
                    //forecast_alert_title = data['alerts'][0]['response'][i]['details']['name'];
                    /*
                    forecast_alert_title = aeris_coded_alerts(data['alerts'][0]['response'][i]['details']['type']);
                    if (typeof forecast_alert_title === "undefined") {
                        // If the type can't be decoded then use the raw name in the alert. I have seen this for "Hurricane Local Statement" not matching a coded weather value
                        forecast_alert_title = data['alerts'][0]['response'][i]['details']['name'];
                    }
                    */
                    forecast_alert_title = "$obs.label.forecast_alert_title: " + data['alerts'][0]['response'][i]['details']['name'];
                    forecast_alert_body = data['alerts'][0]['response'][i]['details']['body'].replace(/\n/g, '<br>');
                    //forecast_alert_link = data['alerts'][0]['response'][i]['details']['name'];
                    forecast_alert_link = data['alerts'][0]['response'][i]['details']['type'];
                    forecast_alert_begins = tzAdjustedMoment(data['alerts'][0]['response'][i]['timestamps']['begins']).format('$obs.label.time_forecast_alert_expires');
                    forecast_alert_expires = tzAdjustedMoment(data['alerts'][0]['response'][i]['timestamps']['expires']).format('$obs.label.time_forecast_alert_expires');
                    forecast_alerts.push({"title": forecast_alert_title, "body": forecast_alert_body, "link": forecast_alert_link, "begins": forecast_alert_begins, "expires": forecast_alert_expires});
                }
            }
        }

        if (forecast_alerts.length > 0) {
            weiherhammer_debug("Forecast: There are " + forecast_alerts.length + " alert(s).");
            for (i = 0; i < forecast_alerts.length; i++) {

                alert_link = "<i class='fa fa-fw fa-exclamation-triangle'></i> <a href='#forecast-alert-" + i + "' data-toggle='modal' data-target='#forecast-alert-" + i + "'><b>" + forecast_alerts[i]["title"] + "</b>, $obs.label.forecast_alert_begins " + forecast_alerts[i]["begins"] + " $obs.label.forecast_alert_expires " + forecast_alerts[i]["expires"] + "</a><br>";
                jQuery(".wx-stn-alert-text").append(alert_link);

                forecast_alert_modal += "<!-- Forecast Alert Modal " + i + " -->";
                forecast_alert_modal += "<div class='modal fade' id='forecast-alert-" + i + "' tabindex='-1' role='dialog' aria-labelledby='forecast-alert'>";
                forecast_alert_modal += "<div class='modal-dialog' role='document'>";
                forecast_alert_modal += "<div class='modal-content'>";
                forecast_alert_modal += "<div class='modal-header'>";
                forecast_alert_modal += "<button type='button' class='close' data-dismiss='modal' aria-label='Close'><span aria-hidden='true'>&times;</span></button>";
                forecast_alert_modal += "<h4 class='modal-title' id='forecast-alert'>" + forecast_alerts[i]["title"] + "</h4>";
                forecast_alert_modal += "</div>";
                forecast_alert_modal += "<div class='modal-body'>";
                forecast_alert_modal += forecast_alerts[i]["body"];
                forecast_alert_modal += "<br><p><small>" + " $obs.label.forecast_alert_begins " + forecast_alerts[i]["begins"] + " $obs.label.forecast_alert_expires " + forecast_alerts[i]["expires"] + "</small></p>";
                forecast_alert_modal += "</div>";
                forecast_alert_modal += "<div class='modal-footer'>";
                forecast_alert_modal += "<button type='button' class='btn btn-primary' data-dismiss='modal'>$obs.label.close</button>";
                forecast_alert_modal += "</div>";
                forecast_alert_modal += "</div>";
                forecast_alert_modal += "</div>";
                forecast_alert_modal += "</div>";

                jQuery(".wx-stn-alert-text").append(forecast_alert_modal);
            }
            jQuery(".wx-stn-alert").show();
        } else {
            weiherhammer_debug("Forecast: There are no forecast alerts");
            jQuery(".wx-stn-alert").hide();
        }
    } catch (err) {
        console.error("Error update_alerts_data", err);
        console.log(alerts_provider);
        console.log(data);
    }
}

function update_current_data(data, options="all") {
    var current_provider = sessionStorage.getItem('current_provider');
    weiherhammer_debug("Current: Provider is " + current_provider);
    weiherhammer_debug("Current: Updating data");
    weiherhammer_debug(data);

    try {
        if (!data.hasOwnProperty(current_provider)) {
            throw new Error("Forecast JSON file does not contain current data for provider=" + current_provider);
        } else if (!data[current_provider].hasOwnProperty("current")) {
            throw new Error("Forecast JSON file does not contain current data. Provider=" + current_provider);
        } else if (!Array.isArray(data[current_provider]["current"])) {
            throw new Error("Forecast JSON file does not contain current/0 data. Provider=" + current_provider);
        } else if (!data[current_provider]["current"][0].hasOwnProperty("success") || !data[current_provider]["current"][0]["success"]) {
            throw new Error("Provider " + current_provider + " does not contain valid data.");
        } else if (!data[current_provider]["current"][0].hasOwnProperty("response")) {
            throw new Error("Forecast JSON file does not contain current/0/response data. Provider=" + current_provider);
        } else if (!Array.isArray(data[current_provider]["current"][0]["response"])) {
            throw new Error("Forecast JSON file does not contain current/0/response/0 data. Provider=" + current_provider);
        } else if (!data[current_provider]["current"][0]["response"][0].hasOwnProperty("ob")) {
            throw new Error("Forecast JSON file does not contain current/0/response/0/ob data. Provider=" + current_provider);
        }

        // using data from current provider
        data = data[current_provider];
        obs_data = data["current"][0]["response"][0]["ob"];

        if (options == "all" || options == "wxicon") {
            var wxicon = get_relative_url() + "/images/" + aeris_icon(obs_data["icon"]) + ".png";
            jQuery("#wxicon").attr("src", wxicon);
        }
        if (options == "all") {
            var current_update = tzAdjustedMoment(obs_data["timestamp"]).format('$obs.label.time_forecast_last_updated');

            var visibility = "N/A"
            if (obs_data.hasOwnProperty("visibilityKM")) {
                visibility = obs_data["visibilityKM"];
                if (visibility !== null) {
                    visibility = parseFloat(parseFloat(visibility)).toLocaleString("$system_locale_js", {minimumFractionDigits: unit_rounding_array["visibility"], maximumFractionDigits: unit_rounding_array["visibility"]}) + " " + unit_label_array["visibility"];
                } else {
                    visibility = "N/A"
                }
            }
            jQuery(".visibility").html(visibility);

            var cloudcover = "N/A";
            if (obs_data.hasOwnProperty("sky")) {
                cloudcover = obs_data["sky"]
                if (cloudcover !== null) {
                    cloudcover = parseFloat(parseFloat(obs_data["sky"])).toLocaleString("$system_locale_js", {minimumFractionDigits: unit_rounding_array["cloudcover"], maximumFractionDigits: unit_rounding_array["cloudcover"]}) + unit_label_array["cloudcover"];
                } else {
                    cloudcover = "N/A"
                }
            }
            jQuery(".cloudcover").html(cloudcover);

            if (obs_data.hasOwnProperty("weatherPrimaryCoded")) {
                jQuery(".current-obs-text").html(aeris_coded_weather(obs_data["weatherPrimaryCoded"], true));
            } else if (obs_data.hasOwnProperty("weatherPrimary")) {
                jQuery(".current-obs-text").html(obs_data["weatherPrimary"]);
            } else {
                jQuery(".current-obs-text").html("$gettext('unknown')");
            }

            if (data["current"][0].hasOwnProperty("source")) {
                jQuery(".current_provider_source_api").html(data["current"][0]["source"]);
            } else {
                jQuery(".current_provider_source_api").html(current_provider);
            }
        }
    } catch (err) {
        jQuery("#wxicon").attr("src", get_relative_url() + "/images/unknown.png");
        jQuery(".current-obs-text").html("$gettext('unknown')");
        jQuery(".visibility").html("N/A");
        jQuery(".cloudcover").html("N/A");
        jQuery(".current_provider_source_api").html(current_provider);
        console.error("Error update_current_data", err);
        console.log(current_provider);
        console.log(data);
    }
}

function update_forecast_data(data) {
    //TODO build html code in weiherhammer.py, only update html code here
    var forecast_provider = "$forecast_provider";
    weiherhammer_debug("Forecast: Provider is " + forecast_provider);
    weiherhammer_debug("Forecast: Updating data");
    weiherhammer_debug(data);

    try {
        if (!data.hasOwnProperty(forecast_provider)) {
            throw new Error("Forecast JSON file does not contain data for provider=" + forecast_provider);
        }

        //TODO muss hier weg
        try {
            var forecast_issueTime_dwd = tzAdjustedMoment(data["dwd_mosmix"]["current"][0]["response"][0]["obTimestamp"]).format('$obs.label.time_forecast_last_updated');
        } catch (err) {
            // Returned "current" data does not have this value
        }

        // using data from forecast provider
        data = data[forecast_provider];

        //TODO more checks?

        if (pageName == "console.html") {
            var forecast_show_conditions = "$Extras.forecast_show_conditions_console";
            var forecast_show_temperature = "$Extras.forecast_show_temperature_console";
            var forecast_show_pop = "$Extras.forecast_show_pop_console";
            var forecast_show_dewpoint = "$Extras.forecast_show_dewpoint_console";
            var forecast_show_humidity = "$Extras.forecast_show_humidity_console";
            var forecast_show_windspeed = "$Extras.forecast_show_windspeed_console";
            var forecast_show_winddirdeg = "$Extras.forecast_show_winddirdeg_console";
            var forecast_show_pressure = "$Extras.forecast_show_pressure_console";
        } else {
            var forecast_show_conditions = "$Extras.forecast_show_conditions";
            var forecast_show_temperature = "$Extras.forecast_show_temperature";
            var forecast_show_pop = "$Extras.forecast_show_pop";
            var forecast_show_dewpoint = "$Extras.forecast_show_dewpoint";
            var forecast_show_humidity = "$Extras.forecast_show_humidity";
            var forecast_show_windspeed = "$Extras.forecast_show_windspeed";
            var forecast_show_winddirdeg = "$Extras.forecast_show_winddirdeg";
            var forecast_show_pressure = "$Extras.forecast_show_pressure";
        }

        var forecast_subtitle = tzAdjustedMoment(data["timestamp"]).format('$obs.label.time_forecast_last_updated');

        //  start of new composite version of forecast code
        var forecast_types = ["forecast_1hr", "forecast_3hr", "forecast_24hr"];
        var forecast_interval
        for (forecast_interval of forecast_types) {
            var forecast_row = [];
            var output_html = "";
            for (i = 0; i < data[(forecast_interval)][0]["response"][0]["periods"].length; i++) {
                //  for 24hr interval add 7200 (2 hours) to the epoch to get an hour well into the day to avoid any DST issues. This way it'll either be 1am or 2am. Without it, we get 12am or 11pm (the previous day).
                if (forecast_interval == "forecast_24hr") {
                    var image_url = get_relative_url() + "/images/" + aeris_icon(data[(forecast_interval)][0]["response"][0]["periods"][i]["icon"]) + ".png";
                    var condition_text = aeris_coded_weather(data[(forecast_interval)][0]["response"][0]["periods"][i]["weatherPrimaryCoded"], false);
                    var weekday = tzAdjustedMoment(data[(forecast_interval)][0]["response"][0]["periods"][i]["timestamp"] + 7200).format("$obs.label.time_forecast_date");
                } else {
                    var image_url = get_relative_url() + "/images/" + aeris_icon(data[(forecast_interval)][0]["response"][0]["periods"][i]["icon"]) + ".png";
                    var condition_text = aeris_coded_weather(data[(forecast_interval)][0]["response"][0]["periods"][i]["weatherPrimaryCoded"], false);
                    var weekday = tzAdjustedMoment(data[(forecast_interval)][0]["response"][0]["periods"][i]["timestamp"]).format("$obs.label.time_forecast_time");
                }
                // Determine temperature units
                if (("$Extras.forecast_units" == "ca") || ("$Extras.forecast_units" == "uk2") || ("$Extras.forecast_units" == "si")) {
                    avgTemp = data[(forecast_interval)][0]["response"][0]["periods"][i]["avgTempC"];
                    minTemp = data[(forecast_interval)][0]["response"][0]["periods"][i]["minTempC"];
                    maxTemp = data[(forecast_interval)][0]["response"][0]["periods"][i]["maxTempC"];
                    var dewPoint = data[(forecast_interval)][0]["response"][0]["periods"][i]["dewpointC"];
                } else {
                    // Default
                    avgTemp = data[(forecast_interval)][0]["response"][0]["periods"][i]["avgTempF"];
                    minTemp = data[(forecast_interval)][0]["response"][0]["periods"][i]["minTempF"];
                    maxTemp = data[(forecast_interval)][0]["response"][0]["periods"][i]["maxTempF"];
                    var dewPoint = data[(forecast_interval)][0]["response"][0]["periods"][i]["dewpointF"];
                }
                //  for 1hr interval determine temperature range, set to a minimum value of 2; also avoids div by zero
                if (forecast_interval == "forecast_1hr") {
                    if (i == 0) {
                        var lowTemp = avgTemp;
                        var highTemp = avgTemp;
                    } else {
                        if (lowTemp > avgTemp) lowTemp = avgTemp;
                        if (highTemp < avgTemp) highTemp = avgTemp;
                    }
                }
                // Determine wind units
                if ("$unit.unit_type.windSpeed" == "knot") {
                    windSpeed = data[(forecast_interval)][0]["response"][0]["periods"][i]["windSpeedKTS"];
                    windGust = data[(forecast_interval)][0]["response"][0]["periods"][i]["windGustKTS"];
                } else if ("$unit.unit_type.windSpeed" == "beaufort") {
                    windSpeed = kts_to_beaufort(data[(forecast_interval)][0]["response"][0]["periods"][i]["windSpeedKTS"]);
                    windGust = kts_to_beaufort(data[(forecast_interval)][0]["response"][0]["periods"][i]["windGustKTS"]);
                } else if ("$Extras.forecast_units" == "ca") {
                    // ca = kph
                    windSpeed = data[(forecast_interval)][0]["response"][0]["periods"][i]["windSpeedKPH"];
                    windGust = data[(forecast_interval)][0]["response"][0]["periods"][i]["windGustKPH"];
                } else if ("$Extras.forecast_units" == "si") {
                    // si = meters per second. MPS is KPH / 3.6
                    windSpeed = data[(forecast_interval)][0]["response"][0]["periods"][i]["windSpeedKPH"] / 3.6;
                    windGust = data[(forecast_interval)][0]["response"][0]["periods"][i]["windGustKPH"] / 3.6;
                } else {
                    // us and uk2 and default = mph
                    windSpeed = data[(forecast_interval)][0]["response"][0]["periods"][i]["windSpeedMPH"];
                    windGust = data[(forecast_interval)][0]["response"][0]["periods"][i]["windGustMPH"];
                }
                /*
                As per API specification, "pop" is either a number from 0 to
                100 or null. We convert to 0 in the second case.
                */
                var precip = data[(forecast_interval)][0]["response"][0]["periods"][i]["pop"] || 0;
                // Humidity
                var humidity = data[(forecast_interval)][0]["response"][0]["periods"][i]["humidity"];
                /*
                Determine snow unit. "snowCM" and "snowIN" are specified
                to always return a number. We still convert to 0 if we ever get
                null.
                */
                if (("$Extras.forecast_units" == "si") || ("$Extras.forecast_units" == "ca") || ("$Extras.forecast_units" == "uk2")) {
                    var snow_depth = data[(forecast_interval)][0]["response"][0]["periods"][i]["snowCM"] || 0;
                    var snow_unit = "cm";
                } else {
                    var snow_depth = data[(forecast_interval)][0]["response"][0]["periods"][i]["snowIN"] || 0;
                    var snow_unit = "in";
                }
                //  for 24hr interval add 7200 (2 hours) to the epoch to get an hour well into the day to avoid any DST issues. This way it'll either be 1am or 2am. Without it, we get 12am or 11pm (the previous day).
                if (forecast_interval == "forecast_24hr") {
                    var forecast_link_setup = "$Extras.forecast_daily_forecast_link".replace("YYYY", tzAdjustedMoment(data[(forecast_interval)][0]["response"][0]["periods"][i]["timestamp"] + 7200).format("YYYY")).replace("MM", tzAdjustedMoment(data[(forecast_interval)][0]["response"][0]["periods"][i]["timestamp"] + 7200).format("MM")).replace("DD", tzAdjustedMoment(data[(forecast_interval)][0]["response"][0]["periods"][i]["timestamp"] + 7200).format("DD"));
                } else {
                    var forecast_link_setup = "$Extras.forecast_daily_forecast_link".replace("YYYY", tzAdjustedMoment(data[(forecast_interval)][0]["response"][0]["periods"][i]["timestamp"]).format("YYYY")).replace("MM", tzAdjustedMoment(data[(forecast_interval)][0]["response"][0]["periods"][i]["timestamp"]).format("MM")).replace("DD", tzAdjustedMoment(data[(forecast_interval)][0]["response"][0]["periods"][i]["timestamp"]).format("DD"));
                }
                var forecast_link = '<a href="' + forecast_link_setup + '" target="_blank">$obs.label.daily_forecast</a>';
                var windDirDEG = data[(forecast_interval)][0]["response"][0]["periods"][i]["windDirDEG"] || 0;
                var windDir = data[(forecast_interval)][0]["response"][0]["periods"][i]["windDir"] || 0;
                var pressureMB = data[(forecast_interval)][0]["response"][0]["periods"][i]["pressureMB"] || 0;
                forecast_row.push({
                    "weekday": weekday,
                    "image_url": image_url,
                    "condition_text": condition_text,
                    "avgTemp": avgTemp,
                    "minTemp": minTemp,
                    "maxTemp": maxTemp,
                    "windSpeed": windSpeed,
                    "windGust": windGust,
                    "snow_depth": snow_depth,
                    "snow_unit": snow_unit,
                    "precip": precip,
                    "humidity": humidity,
                    "dewPoint": dewPoint,
                    "forecast_link": forecast_link,
                    "windDirDEG": windDirDEG,
                    "windDir": windDir,
                    "pressureMB": pressureMB
                });
            }
            //  Create individual forecast rows
            if (forecast_interval == "forecast_1hr") {
                //  set temperature range and offset to centralise output
                var rangeTemp = highTemp - lowTemp;
                var offset = 0;
                if (highTemp - lowTemp < 2) {
                    rangeTemp = 2;
                    if (highTemp - lowTemp == 0) offset = 1; //sets the only value 1/2 way down
                    else if (highTemp - lowTemp == 1) offset = 0.67;  //sets the top value 1/3 way down
                }
                // Build 1 hour forecast row
                for (i = 0; i < forecast_row.length; i++) {
                    if (i == 0) {
                        output_html += '<div class="col-sm-1-5 forecast-day forecast-1hour forecast-today">';
                    } else {
                        output_html += '<div class="col-sm-1-5 forecast-day forecast-1hour border-left">';
                    }
                    output_html += '<span id="weekday">' + forecast_time(i, forecast_interval, forecast_row[i]["weekday"]) + '</span>';
                    output_html += '<br>';
                    //TODO forecast_show_conditions/forecast_show_temperature
                    if (pageName == "console.html") {
                        output_html += '<div class="forecast-conditions-1hour">';
                        output_html += '<img id="icon" src="' + forecast_row[i]["image_url"] + '">';
                        output_html += '<br>';
                        output_html += '<span class="forecast-condition-text">' + forecast_row[i]["condition_text"] + '</span>';
                        output_html += '</div>';
                        output_html += '<span class="forecast-avg">' + parseFloat(forecast_row[i]["maxTemp"]).toFixed(0) + '&deg;</span>';
                        output_html += '<br>';
                    } else {
                        output_html += '<div class="forecast-conditions">';
                        output_html += '<div class="forecast-temp-graph" style="padding-top:';
                        //  padding = ( ( highTemp - forecast_row[i]["avgTemp"] = offset ) * 100 / ( rangeTemp) ) where 100 ~ max calculated space available for padding 
                        output_html += parseInt((highTemp - forecast_row[i]["avgTemp"] + offset) * 100 / (rangeTemp)) + 'px">';
                        output_html += '<div class="forecast-image">';
                        output_html += '<img id="icon" src="' + forecast_row[i]["image_url"] + '">';
                        output_html += '</div>';
                        output_html += parseFloat(forecast_row[i]["avgTemp"]).toFixed(0) + '&deg;</div>';
                        output_html += '</div>';
                    }
                    if (forecast_show_dewpoint == "1") {
                        output_html += '<div class="forecast-dewpoint">';
                        output_html += '<i class="wi wi-thermometer wi-raindrops rain-precip"></i> <span>' + parseFloat(forecast_row[i]["dewPoint"]).toFixed(0) + '&deg;</span>';
                        output_html += '</div>';
                    }
                    if (forecast_show_pop == "1") {
                        output_html += '<div class="forecast-precip">';
                        if (forecast_row[i]["snow_depth"] > 0) {
                            output_html += '<div class="snow-precip">';
                            // output_html += '<img src="'+get_relative_url()+'/images/snowflake-icon-15px.png"> <span>';
                            output_html += '<img src="' + get_relative_url() + '/images/snowflake-icon-15px.png"> <span>' + parseFloat(forecast_row[i]["snow_depth"]).toFixed(0) + '<span> ' + forecast_row[i]["snow_unit"];
                            output_html += '</div>';
                        } else if (forecast_row[i]["precip"] > 0) {
                            output_html += '<i class="fa fa-fw fa-umbrella rain-precip"></i> <span>' + parseFloat(forecast_row[i]["precip"]).toFixed(0) + '%</span>';
                        } else {
                            output_html += '<i class="fa fa-fw fa-umbrella rain-no-precip"></i> <span>0%</span>';
                        }
                        output_html += '</div>';
                    }
                    if (forecast_show_humidity == "1") {
                        output_html += '<div class="forecast-humidity">';
                        output_html += '<i class="wi wi-humidity humidity-forecast"></i> <span>' + parseFloat(forecast_row[i]["humidity"]).toFixed(0) + '%</span>';
                        output_html += '</div>';
                    }
                    if (forecast_show_windspeed == "1") {
                        output_html += '<div class="forecast-wind" rel="tooltip" title="' + '$unit.label.windSpeed' + '">';
                        output_html += '<i class="wi wi-strong-wind"></i> <span>'+ parseFloat(forecast_row[i]["windSpeed"]).toFixed(0) + '</span>|<span>' + parseFloat(forecast_row[i]["windGust"]).toFixed(0) + '</span>';        
                        output_html += '</div>';
                    }
                    if (forecast_show_winddirdeg == "1") {
                        output_html += '<div class="forecast-winddirdeg">';
                        output_html += '<i class="wi wi-wind wi-from-n" style="transform:rotate(' + parseFloat(forecast_row[i]["windDirDEG"]).toFixed(0) + 'deg);font-size:30px"></i> <span style="font-size:12px">' + forecast_row[i]["windDir"] + '</span>';
                        output_html += '</div>';
                    }
                    if (forecast_show_pressure == "1") {
                        output_html += '<div class="forecast-pressure" rel="tooltip" title="' + '$unit.label.barometer' + '">';
                        output_html += '<i class="wi wi-barometer"></i> <span>' + parseFloat(forecast_row[i]["pressureMB"]).toFixed(0) + '</span>';
                        output_html += '</div>';
                    }
                    #if $Extras.has_key("forecast_show_daily_forecast_link") and $Extras.forecast_show_daily_forecast_link == '1'
                    output_html += forecast_row[i]["forecast_link"];
                    #end if
                    output_html += '</div>';
                }
            } else {
                // Build 3 or 24 hour forecast rows
                for (i = 0; i < forecast_row.length; i++) {
                    if (forecast_interval == "forecast_3hr") {
                        if (i == 0) {
                            output_html += '<div class="col-sm-1-5 forecast-day forecast-3hour forecast-today">';
                        } else {
                            output_html += '<div class="col-sm-1-5 forecast-day forecast-3hour border-left">';
                        }
                    } else if (forecast_interval == "forecast_24hr") {
                        if (i == 0) {
                            output_html += '<div class="col-sm-1-5 forecast-day forecast-24hour forecast-today">';
                        } else {
                            output_html += '<div class="col-sm-1-5 forecast-day forecast-24hour border-left">';
                        }
                    }
                    output_html += '<span id="weekday">' + forecast_time(i, forecast_interval, forecast_row[i]["weekday"]) + '</span>';
                    output_html += '<br>';
                    if (forecast_show_conditions == "1") {
                        output_html += '<div class="forecast-conditions">';
                        output_html += '<img id="icon" src="' + forecast_row[i]["image_url"] + '" alt="Vorhersagesymbol ' + forecast_row[i]["weekday"] + '">';
                        output_html += '<div class="forecast-condition-text">' + forecast_row[i]["condition_text"] + '</div>';
                        output_html += '</div>';
                    }
                    if (forecast_show_temperature == "1") {
                        output_html += '<div class="forecast-high">' + parseFloat(forecast_row[i]["minTemp"]).toFixed(0) + '&deg;</span> | <span class="forecast-low">' + parseFloat(forecast_row[i]["maxTemp"]).toFixed(0) + '&deg;</div>';
                    }
                    if (forecast_show_dewpoint == "1") {
                        output_html += '<div class="forecast-dewpoint">';
                        output_html += '<i class="wi wi-thermometer wi-raindrops rain-precip"></i> <span>' + parseFloat(forecast_row[i]["dewPoint"]).toFixed(0) + '&deg;</span>';
                        output_html += '</div>';
                    }
                    if (forecast_show_pop == "1") {
                        output_html += '<div class="forecast-precip">';
                        if (forecast_row[i]["snow_depth"] > 0) {
                            output_html += '<div class="snow-precip">';
                            output_html += '<img src="' + get_relative_url() + '/images/snowflake-icon-15px.png"> <span>' + parseFloat(forecast_row[i]["snow_depth"]).toFixed(0) + '<span> ' + forecast_row[i]["snow_unit"];
                            output_html += '</div>';
                        } else if (forecast_row[i]["precip"] > 0) {
                            output_html += '<i class="fa fa-fw fa-umbrella rain-precip"></i> <span>' + parseFloat(forecast_row[i]["precip"]).toFixed(0) + '%</span>';
                        } else {
                            output_html += '<i class="fa fa-fw fa-umbrella rain-no-precip"></i> <span>0%</span>';
                        }
                        output_html += '</div>';
                    }
                    if (forecast_show_humidity == "1") {
                        output_html += '<div class="forecast-humidity">';
                        output_html += '<i class="wi wi-humidity humidity-forecast"></i> <span>' + parseFloat(forecast_row[i]["humidity"]).toFixed(0) + '%</span>';
                        output_html += '</div>';
                    }
                    if (forecast_show_windspeed == "1") {
                        output_html += '<div class="forecast-wind">';
                        output_html += '<i class="wi wi-strong-wind"></i> <span>' + parseFloat(forecast_row[i]["windSpeed"]).toFixed(0) + '</span> | <span> ' + parseFloat(forecast_row[i]["windGust"]).toFixed(0) + '$unit.label.windSpeed' + '</span>';
                        output_html += '</div>';
                    }
                    if (forecast_show_winddirdeg == "1") {
                        output_html += '<div class="forecast-winddirdeg">';
                        output_html += '<i class="wi wi-wind wi-from-n" style="transform:rotate(' + parseFloat(forecast_row[i]["windDirDEG"]).toFixed(0) + 'deg);font-size:30px"></i> <span>' + forecast_row[i]["windDir"] + '</span>';
                        output_html += '</div>';
                    }
                    if (forecast_show_pressure == "1") {
                        output_html += '<div class="forecast-pressure">';
                        output_html += '<i class="wi wi-barometer"></i> <span>' + parseFloat(forecast_row[i]["pressureMB"]).toFixed(0) + '$unit.label.barometer' + '</span>';
                        output_html += '</div>';
                    }
                    #if $Extras.has_key("forecast_show_daily_forecast_link") and $Extras.forecast_show_daily_forecast_link == '1'
                    output_html += forecast_row[i]["forecast_link"];
                    #end if
                    output_html += '</div>';
                }
            }
            // Show the forecasts rows
            if (forecast_interval == "forecast_1hr") {
                jQuery(".1hr_forecasts").html(output_html);
                weiherhammer_debug("html_1hr: " + output_html);
            } else if (forecast_interval == "forecast_3hr") {
                jQuery(".3hr_forecasts").html(output_html);
                weiherhammer_debug("html_3hr: " + output_html);
            } else if (forecast_interval == "forecast_24hr") {
                jQuery(".24hr_forecasts").html(output_html);
                weiherhammer_debug("html_24hr: " + output_html);
            }
            // Show the forecast_subtitle
            jQuery(".forecast-subtitle").html("$obs.label.forecast_last_updated " + forecast_subtitle);
            jQuery(".forecast-issueTime-dwd").html(forecast_issueTime_dwd);
        }
    } catch (err) {
        forecast_select(0);
        console.error("Error update_forecast_data", err);
        console.log(forecast_provider);
        console.log(data);
    }
}

#end if

//  function to display selected forecast according to value of interval (1, 3 or 24); 0 hides all forecasts
function forecast_select(interval, force=false) {
    if (interval == 0) {
        jQuery(".forecastrow").hide();
    } else {
        oldinterval = sessionStorage.getItem("forecastInterval");
        if (interval != oldinterval || force) {
            //  hide the old forecast
            var forecast = document.getElementById((oldinterval + "hour-selected-forecast"));
            var button = document.getElementById(("button" + oldinterval));
            if (forecast != null) forecast.style.display = "none";
            if (button != null) button.style.borderStyle = "hidden";
            //  display the new forecast and store its interval value
            forecast = document.getElementById((interval + "hour-selected-forecast"));
            button = document.getElementById(("button" + interval));
            if (forecast != null) forecast.style.display = "block";
            if (button != null) button.style.borderStyle = "solid";
            sessionStorage.setItem("forecastInterval", interval);
        }
    }
}

function forecast_default(interval) {
    sessionStorage.setItem("defaultInterval", interval);
}

//  function adjusts daytime format for forecast_1hr & _3hr; assumes "ddd LT" format for daytime
function forecast_time(i, interval, daytime) {
    if ((daytime.indexOf(" ") == -1) || (interval == "forecast_24hr")) return daytime;
    var output = daytime
    var strday = daytime.substr(0, daytime.indexOf(" "));
    var strtime = daytime.substr(daytime.indexOf(" ") + 1);
    if (interval == "forecast_1hr") {
        if ((i == 0) || (strtime == "00:00") || (strtime == "12:00 AM")) {
            output = strtime + "<br>" + strday;
        } else {
            output = strtime + "<br>";
        }
    } else if (interval == "forecast_3hr") {
        if ((i != 0) && ((strtime > "02:59") || (strtime > "02:59 AM"))) {
            output = strtime;
        }
    }
    return output;
}

#if $Extras.has_key("mqtt_websockets_enabled") and $Extras.mqtt_websockets_enabled == '1'

// ============================================
// Live website using MQTT Websockets enabled
// ============================================

var mqttConnected = false;
//TODO alle Bilder dabei?
function ajaximages(section = false, reload_timer_interval_seconds = false) {
    // This function only runs if the elements have an img src.
    // Update images within the specific section
    if (!section || section == "radar") {
        weiherhammer_debug("Updating radar image");

        // Reload only Windy Radar
        if (document.querySelectorAll(".radar_image img").length > 0) {
            var radar_img = document.querySelectorAll(".radar_image img")[0].src;
            var new_radar_img = radar_img + "&t=" + Math.floor(Math.random() * 999999999);
            document.querySelectorAll(".radar_image img")[0].src = new_radar_img;
            //var radar_html = jQuery('.radar-map').children('img').attr('src').split('?')[0] // Get the img src and remove everything after "?" so we don't stack ?'s onto the image during updates
            //jQuery('.radar-map').children('img').attr('src', radar_html + "?" + Math.floor(Math.random() * 999999999));
        }

        // Reload iframe - https://stackoverflow.com/a/4249946/1177153
        //if (document.querySelectorAll(".radar-map iframe").length > 0) {
        if (document.querySelectorAll(".radar_mage iframe").length > 0) {
            jQuery(".radar_image iframe").each(function() {
                jQuery(this).attr('src', function(i, val) {return val;});
            });
        }
        } else if (!section || section != "radar") {
        weiherhammer_debug("Updating " + section + " images");

        // Reload images
        jQuery('.' + section + ' img').each(function() {
            new_image_url = jQuery(this).attr('src').split('?')[0] + "?" + Math.floor(Math.random() * 999999999);
            jQuery(this).attr('src', new_image_url);
        });

        // Reload iframes
        jQuery('.' + section + ' iframe').each(function() {
            jQuery(this).attr('src', function(i, val) {return val;});
        });
    }

    // Set the new timer
    if (reload_timer_interval_seconds) {
        var reload_timer_ms = reload_timer_interval_seconds * 1000; // convert to millis
        setTimeout(function() {ajaximages(section, reload_timer_interval_seconds);}, reload_timer_ms);
    }
}

var reconnect_using_inactive_timestamp = false;
var inactive_timestamp = "";

// MQTT connect
function connect() {
    #if $Extras.has_key("mqtt_websockets_ssl") and $Extras.mqtt_websockets_ssl == '1'
    weiherhammer_debug("MQTT: Connecting to MQTT Websockets: $Extras.mqtt_websockets_host $Extras.mqtt_websockets_port (SSL Enabled)");
    #else
    weiherhammer_debug("MQTT: Connecting to MQTT Websockets: $Extras.mqtt_websockets_host $Extras.mqtt_websockets_port (SSL Disabled)");
    #end if
    if (reconnect_using_inactive_timestamp) {
            updated = tzAdjustedMoment(inactive_timestamp).format("$obs.label.time_last_updated");
        } else {
            updated = tzAdjustedMoment("$current.dateTime.raw").format("$obs.label.time_last_updated");
        }
    reported = "$obs.label.mqtt_websockets_connecting $obs.label.header_last_updated " + updated;
    jQuery(".updated").html(reported);
    jQuery(".onlineMarker").hide();
    jQuery(".offlineMarker").hide();
    jQuery(".loadingMarker").show();

    #if $Extras.has_key("mqtt_websockets_host_kiosk") and $Extras.mqtt_websockets_host_kiosk != ""
    if (pageName == "kiosk.html") {
        #if $Extras.has_key("mqtt_websockets_ssl_kiosk") and $Extras.mqtt_websockets_ssl_kiosk == '1'
        weiherhammer_debug("MQTT: Connecting to MQTT Websockets: $Extras.mqtt_websockets_host_kiosk $mqtt_websockets_port_kiosk (SSL Enabled)");
        var useSSL = true;
        #else
        weiherhammer_debug("MQTT: Connecting to MQTT Websockets: $Extras.mqtt_websockets_host_kiosk $mqtt_websockets_port_kiosk (SSL Disabled)");
        var useSSL = false;
        #end if
        client = new Paho.Client("$Extras.mqtt_websockets_host_kiosk", $mqtt_websockets_port_kiosk, mqttclient);
    }
    else {
        #if $Extras.has_key("mqtt_websockets_ssl") and $Extras.mqtt_websockets_ssl == '1'
        weiherhammer_debug("MQTT: Connecting to MQTT Websockets: $Extras.mqtt_websockets_host $Extras.mqtt_websockets_port (SSL Enabled)");
        var useSSL = true;
        #else
        weiherhammer_debug("MQTT: Connecting to MQTT Websockets: $Extras.mqtt_websockets_host $Extras.mqtt_websockets_port (SSL Disabled)");
        var useSSL = false;
        #end if
        client = new Paho.Client("$Extras.mqtt_websockets_host", $Extras.mqtt_websockets_port, mqttclient);
    }
    #elif $Extras.has_key("mqtt_websockets_host_console") and $Extras.mqtt_websockets_host_console != ""
    if (pageName == "console.html") {
        #if $Extras.has_key("mqtt_websockets_ssl_console") and $Extras.mqtt_websockets_ssl_console == '1'
        weiherhammer_debug("MQTT: Connecting to MQTT Websockets: $Extras.mqtt_websockets_host_console $mqtt_websockets_port_console (SSL Enabled)");
        var useSSL = true;
        #else
        weiherhammer_debug("MQTT: Connecting to MQTT Websockets: $Extras.mqtt_websockets_host_console $mqtt_websockets_port_console (SSL Disabled)");
        var useSSL = false;
        #end if
        client = new Paho.Client("$Extras.mqtt_websockets_host_console", $mqtt_websockets_port_console, mqttclient);
    }
    else {
        #if $Extras.has_key("mqtt_websockets_ssl") and $Extras.mqtt_websockets_ssl == '1'
        weiherhammer_debug("MQTT: Connecting to MQTT Websockets: $Extras.mqtt_websockets_host $Extras.mqtt_websockets_port (SSL Enabled)");
        var useSSL = true;
        #else
        weiherhammer_debug("MQTT: Connecting to MQTT Websockets: $Extras.mqtt_websockets_host $Extras.mqtt_websockets_port (SSL Disabled)");
        var useSSL = false;
        #end if
        client = new Paho.Client("$Extras.mqtt_websockets_host", $Extras.mqtt_websockets_port, mqttclient);
    }
    #else
    #if $Extras.has_key("mqtt_websockets_ssl") and $Extras.mqtt_websockets_ssl == '1'
    weiherhammer_debug("MQTT: Connecting to MQTT Websockets: $Extras.mqtt_websockets_host $Extras.mqtt_websockets_port (SSL Enabled)");
    var useSSL = true;
    #else
    weiherhammer_debug("MQTT: Connecting to MQTT Websockets: $Extras.mqtt_websockets_host $Extras.mqtt_websockets_port (SSL Disabled)");
    var useSSL = false;
    #end if
    client = new Paho.Client("$Extras.mqtt_websockets_host", $Extras.mqtt_websockets_port, mqttclient);
    #end if
    client.onConnectionLost = onConnectionLost;
    client.onMessageArrived = onMessageArrived;
    var options = {
        useSSL: useSSL,
        #if $Extras.has_key("mqtt_websockets_username") and $Extras.has_key("mqtt_websockets_password") and $Extras.mqtt_websockets_username != "" and $Extras.mqtt_websockets_password != ""
        userName:"$Extras.mqtt_websockets_username",
        password:"$Extras.mqtt_websockets_password",
        #end if
        // mqttVersion: 4 is spec MQTTv3.1.1 - mqttVersion: 3 is spec MQTTv3.1
        mqttVersion: 4,
        // If mqttVersionExplicit is true, it will force the connection to use the selected MQTT Version or will fail to connect.
        // If mqttVersionExplicit is false and mqttVersion is 4, it will try mqttVersion: 4 and if it fails it will fallback to mqttVersion: 3
        // Here's the relevant code: https://github.com/eclipse/paho.mqtt.javascript/blob/f5859463aba9a9b7c19f99ab7c4849a723f8d832/src/paho-mqtt.js#L1610
        mqttVersionExplicit: false,
        reconnect: true,
        onSuccess: onConnect,
        onFailure: onFailure
    }
    client.connect(options);
}

// MQTT connect callback
function onConnect() {
    mqttConnected = true;
    weiherhammer_debug("MQTT: MQTT Connected. Subscribing.");
    if (reconnect_using_inactive_timestamp) {
        updated = tzAdjustedMoment(inactive_timestamp).format("$obs.label.time_last_updated");
    } else {
        updated = tzAdjustedMoment("$current.dateTime.raw").format("$obs.label.time_last_updated");
    }
    if (pageName == "pi") {
        reported = "$obs.label.mqtt_websockets_waiting_pi $obs.label.header_last_updated " + updated;
    } else {
        reported = "$obs.label.mqtt_websockets_waiting $obs.label.header_last_updated " + updated;
    }
    jQuery(".updated").html(reported);
    jQuery(".onlineMarker").hide();
    jQuery(".offlineMarker").hide();
    jQuery(".loadingMarker").show();
    client.subscribe("$Extras.mqtt_websockets_topic");
    #if $Extras.has_key("disconnect_live_website_visitor") and $Extras.disconnect_live_website_visitor != '0'
    if (getURLvar("stayconnected") && (getURLvar("stayconnected") == "true" || getURLvar("stayconnected") == "1")) {
        weiherhammer_debug("MQTT: stayconnected URL var found: ignoring disconnect_live_website_visitor value");
    } else {
        if  (pageName == "pi" || pageName == "kiosk.html" || pageName == "console.html") {
            weiherhammer_debug("MQTT: ignoring disconnect_live_website_visitor value for page: " + pageName);
        }
        else {
            var activityTimeout = setTimeout(inactive, $Extras.disconnect_live_website_visitor); // Stop automatic ajax refresh
        }
    }
    #end if
}

// MQTT Failure
function onFailure() {
    mqttConnected = false;
    jQuery(".onlineMarker").hide();
    jQuery(".offlineMarker").show();
    jQuery(".loadingMarker").hide();
    var d = new Date();
    epoch = parseFloat((d / 1000)).toFixed(0); // Convert millis to seconds
    if (client.isConnected()) {
        updated = tzAdjustedMoment(epoch).format("$obs.label.time_last_updated");
    } else {
        updated = tzAdjustedMoment("$current.dateTime.raw").format("$obs.label.time_last_updated");
    }
    jQuery(".updated").html("$obs.label.mqtt_websockets_failed $obs.label.header_last_updated " + updated);
    console.log("MQTT: " + tzAdjustedMoment(epoch).format() + ": Cannot connect to MQTT broker");
    if (pageName == "mqttmon") {
        setTimeout(mqttmon_mark_outdated, (mqttmon_outdated_treshold * 1000) + 10000);
    }
}

// MQTT connection lost
function onConnectionLost(responseObject) {
    mqttConnected = false;
    jQuery(".onlineMarker").hide();
    jQuery(".offlineMarker").show();
    jQuery(".loadingMarker").hide();
    var d = new Date();
    epoch = parseFloat((d / 1000)).toFixed(0);  // Convert millis to seconds
    if (client.isConnected()) {
        updated = tzAdjustedMoment(epoch).format("$obs.label.time_last_updated");
    } else {
        updated = tzAdjustedMoment("$current.dateTime.raw").format("$obs.label.time_last_updated");
    }
    jQuery(".updated").html("$obs.label.mqtt_websockets_lost $obs.label.header_last_updated " + updated);
    if (responseObject.errorCode !== 0) {
        console.log("MQTT: " + tzAdjustedMoment(epoch).format() + ": mqtt Connection Lost: " + responseObject.errorMessage);
    }
    if (pageName == "mqttmon") {
        setTimeout(mqttmon_mark_outdated, (mqttmon_outdated_treshold * 1000) + 10000);
    }
}

function inactive() {
    client.disconnect(); // Disconnect mqtt
    weiherhammer_debug("MQTT: Inactive timer expired. MQTT Disconnected");
    jQuery(".onlineMarker").hide(); // Hide online beacon
    jQuery(".offlineMarker").show(); // Show offline beacon
    jQuery(".loadingMarker").hide(); // Hide loading beacon
    var d = new Date();
    epoch = parseFloat((d / 1000)).toFixed(0);  // Convert millis to seconds
    updated = tzAdjustedMoment(epoch).format("$obs.label.time_last_updated");
    jQuery(".updated").html("$obs.label.mqtt_websockets_stopped $obs.label.header_last_updated " + updated + " <button type='button' class='btn btn-primary restart-interval'>$obs.label.mqtt_websockets_continue</button>");
    reconnect_using_inactive_timestamp = true; // Set a flag to use the inactive timestamp in case we reconnect we have the latest last updated time
    inactive_timestamp = epoch; // Store this timestamp in case we reconnect
    if (pageName == "mqttmon") {
        setTimeout(mqttmon_mark_outdated, (mqttmon_outdated_treshold * 1000) + 10000);
    }
}

var mqtt_payload = "";
// New message from mqtt, process it
function onMessageArrived(message) {
    weiherhammer_debug("MQTT: " + message.payloadString);
    update_with_mqtt_data(message.payloadString);
    mqtt_payload = jQuery.parseJSON(message.payloadString);
}

function refreshHooks() {
    // Empty function for hooks to extend/re-use
    //weiherhammer_debug(mqtt_payload);
}

#if $Extras.has_key("mqttmon_format_toggle") and $Extras.mqttmon_format_toggle == "1"
function mqttmon_switch_format() {
    var checked = jQuery("#" + "mqttmonFormatSwitch").prop("checked");
    if (checked) {
        mqttmon_format_user = mqttmon_format_default;
    } else {
        mqttmon_format_user = "raw";
    }
    sessionStorage.setItem("mqttmon_format_user", mqttmon_format_user);
    //console.log(sessionStorage.getItem("mqttmon_format_user"));

    try {
        jQuery('.mqttmon-data').find("span").each(function() {
            var elementClass = jQuery(this).attr("class");
            if (elementClass == null) {
                return true;
            }
            if (!jQuery("." + elementClass).data('raw')) {
                // console.log("class " + elementClass + " has no data raw.");
                return true;
            }
            if (!jQuery("." + elementClass).data('formatted')) {
                // console.log("class " + elementClass + " has no data formatted.");
                return true;
            }
            data_raw = jQuery('.' + elementClass).data("raw");
            data_formatted = jQuery('.' + elementClass).data("formatted");
            data_title = jQuery('.' + elementClass).prop("title");
            if (mqttmon_format_user == "formatted") {
                jQuery('.' + elementClass).text(data_formatted);
                if (data_title == data_formatted) {
                    data_title = jQuery('.' + elementClass).prop("title", data_raw);
                }
            } else {
                jQuery('.' + elementClass).text(data_raw);
                if (data_title == data_raw) {
                    data_title = jQuery('.' + elementClass).prop("title", data_formatted);
                }
            }
        });
    } catch (err) {
        console.error("Error mqttmon_switch_format", err);
    }
}
#end if

function mqttmon_mark_outdated() {
    var now_ts =  moment().unix();

    try {
        jQuery('.mqttmon-data').find("span").each(function() {
            var elementClass = jQuery(this).attr("class");
            if (elementClass == null) {
                return true;
            }
            if (!jQuery("." + elementClass).data('received_ts')) {
                // console.log("class " + elementClass + " has no data received_ts.");
                return true;
            }
            // if (typeof jQuery("." + elementClass).data('received_ts') === 'undefined') {
                // console.log("class " + elementClass + " has undefined data received_ts.");
                // return true;
            // }
            // get last ts
            var last_ts = parseInt(jQuery('.' + elementClass).data('received_ts'));

            if (last_ts > 0) {
                if (now_ts - last_ts > mqttmon_outdated_treshold) {
                   // update element as received
                   jQuery('.' + elementClass + '-mqttmon-rcv-dot').css('background-color', 'var(--mqttmon-rcv-dot-outdated)');
                }
            }
        });
    } catch (err) {
        console.error("Error mqttmon_mark_outdated", err);
    }
}

// Handle MQTT message
function update_with_mqtt_data(data) {
    weiherhammer_debug("Updating with MQTT data");
    var data = jQuery.parseJSON(data);

    try {
        refreshHooks();
    } catch (e) {
        console.log(e);
    }
    
    #if $Extras.has_key('googleAnalyticsId')
    // Send a pageview
    gtag('config', '$Extras.googleAnalyticsId');
    #end if

    // This message is a weewx archive update. Update weewx data, forecast data and highcharts graphs
    if (data.hasOwnProperty("interval")) {
        // Delays are recommended to allow the other skins to complete processing
        weiherhammer_debug("MQTT: MQTT message indicates this is an archive interval.");
        if (pageName == "pi" || pageName == "kiosk.html" || pageName == "console.html") {
            weiherhammer_debug("Skipping chart update for page " + pageName + ", no charts to be updated.");
        }
        else {
            setTimeout(showChart, 20000, homepage_graphgroup); // Load updated charts.
        }
        ajaxweewx().then(function(weewx_data) { // This call will make sure json/weewx_data.json is loaded before anything else
            //TODO brauch ich das wirklich?
            //setTimeout(update_with_weewx_data.bind(null, weewx_data, true), 20000); // Initial call to update (date, daily high, low, etc)
            //setTimeout(weiherhammer_debug.bind(null, weewx_data), 20000); // Make weewx_data.json available in debugging console
        #if $Extras.has_key("forecast_enabled") and $Extras.forecast_enabled == '1'
            setTimeout(ajaxforecast, 10000); // Update forecast data
        #end if
        }).catch(function(e) {
            console.log(e);
        });
    } else {
        // Only show the updated time on non-archive packets
        var epoch = parseFloat(data["dateTime"]).toFixed(0);
        var updated = tzAdjustedMoment(epoch).format("$obs.label.time_last_updated");
        if (pageName == "pi") {
            var updated_text = "$obs.label.mqtt_websockets_connected_pi " + updated;
        } else {
            var updated_text = "$obs.label.mqtt_websockets_connected " + updated;
        }
        jQuery(".updated").html(updated_text);
    }

    // If we're in this function, show the online beacon and hide the others
    jQuery(".onlineMarker").show(); // Show the online beacon
    jQuery(".offlineMarker").hide();
    jQuery(".loadingMarker").hide();

    if (pageName == "homepage") {
        // all obs with class = obs or class = obs_formatted
        try {
            jQuery.each(data, function(data_class, data_raw) {
                //TODO
                if (data_class == "sum_sunshineDur_sum") {
                    return;
                }
                if (!unit_rounding_array.hasOwnProperty(data_class)) {
                    unit_rounding_array[data_class] = unit_rounding_array["default"]
                }
                if (!unit_label_array.hasOwnProperty(data_class)) {
                    unit_label_array[data_class] = unit_label_array["default"]
                }
                if (jQuery('.' + data_class).length > 0) {
                    // general (class = obs)
                    jQuery("." + data_class).html(parseFloat(parseFloat(data_raw)).toLocaleString("$system_locale_js", {minimumFractionDigits: unit_rounding_array[data_class], maximumFractionDigits: unit_rounding_array[data_class]}) + unit_label_array[data_class]);
                }
                if (jQuery('.' + data_class + "_formatted").length > 0) {
                    // obs_formatted
                    jQuery("." + data_class + "_formatted").html(parseFloat(parseFloat(data_raw)).toLocaleString("$system_locale_js", {minimumFractionDigits: unit_rounding_array[data_class], maximumFractionDigits: unit_rounding_array[data_class]}));
                }
            });
        } catch (err) {
            console.error("Error update_with_mqtt_data", err);
        }

        // temperature observations
        try {
            // Tooltip
            if (data.hasOwnProperty("day_outTemp_mindate")) {
                var value = tzAdjustedMoment(parseFloat(data["day_outTemp_mindate"]).toFixed(0)).format("$obs.label.time_summaries_day");
                jQuery(".day_outTemp_min").prop("title", "$obs.label.summaries_date_ttt" + value);
            }
            if (data.hasOwnProperty("day_outTemp_maxdate")) {
                var value = tzAdjustedMoment(parseFloat(data["day_outTemp_maxdate"]).toFixed(0)).format("$obs.label.time_summaries_day");
                jQuery(".day_outTemp_max").prop("title", "$obs.label.summaries_date_ttt" + value);
            }
        } catch (err) {
            console.error("Error update_with_mqtt_data", err);
        }

        // wind observations
        try {
            if (data.hasOwnProperty("windDir")) {
                // without unit
                jQuery(".curwinddir").html(highcharts_tooltip_factory(parseFloat(data["windDir"]).toFixed(0), "windDir"));
                jQuery(".curwinddeg").html(parseFloat(data["windDir"]).toFixed(0) + "&deg;");
                if (!data.hasOwnProperty("windSpeed")) {
                    data["windSpeed"] = "N/A";
                }
                rotateWindDir(data["windDir"], data["windSpeed"]);
            }
            if (data.hasOwnProperty("windSpeed")) {
                // without unit
                jQuery(".windSpeed_formatted").html(parseFloat(parseFloat(data["windSpeed"])).toLocaleString("$system_locale_js", {minimumFractionDigits: unit_rounding_array["windSpeed"], maximumFractionDigits: unit_rounding_array["windSpeed"]}));
                if (!data.hasOwnProperty("windDir")) {
                    data["windDir"] = "N/A";
                }
                rotateWindDir(data["windDir"], data["windSpeed"]);
            }
        } catch (err) {
            console.error("Error update_with_mqtt_data", err);
        }

        // aqi
        #if $Extras.has_key("aqi_enabled") and $Extras.aqi_enabled == '1'
        try {
            // aqi properties
            if (vdp_array.hasOwnProperty("aqi")) {
                if (vdp_array["aqi"].hasOwnProperty("obs")) {
                    var vals = vdp_array["aqi"]["obs"];
                    for (var i = 0; i < vals.length; i++) {
                        if (data.hasOwnProperty(vals[i])) {
                            update_aqi_properties(weewx_data, vals[i], data[vals[i]], ["all"]);
                        }
                    }
                }
            }
        } catch (err) {
            console.error("Error update_with_mqtt_data", err);
        }
        #end if

        // Snapshot Stats Section
        try {
            // Daily Snapshot Stats Section
            // Tooltip
            if (data.hasOwnProperty("day_barometer_mindate")) {
                var value = tzAdjustedMoment(parseFloat(data["day_barometer_mindate"]).toFixed(0)).format("$obs.label.time_summaries_day");
                jQuery(".day_barometer_min").prop("title", "$obs.label.summaries_date_ttt" + value);
            }
            if (data.hasOwnProperty("day_barometer_maxdate")) {
                var value = tzAdjustedMoment(parseFloat(data["day_barometer_maxdate"]).toFixed(0)).format("$obs.label.time_summaries_day");
                jQuery(".day_barometer_max").prop("title", "$obs.label.summaries_date_ttt" + value);
            }
            if (data.hasOwnProperty("day_rainRate_maxdate")) {
                var value = tzAdjustedMoment(parseFloat(data["day_rainRate_maxdate"]).toFixed(0)).format("$obs.label.time_summaries_day");
                jQuery(".day_rainRate_max").prop("title", "$obs.label.summaries_date_ttt" + value);
            }
            if (data.hasOwnProperty("day_wind_maxdate")) {
                var value = tzAdjustedMoment(parseFloat(data["day_wind_maxdate"]).toFixed(0)).format("$obs.label.time_summaries_day");
                jQuery(".day_wind_max").prop("title", "$obs.label.summaries_date_ttt" + value);
            }

            // Monthly Snapshot Stats Section
            // Tooltip
            if (data.hasOwnProperty("month_outTemp_mindate")) {
                var value = tzAdjustedMoment(parseFloat(data["month_outTemp_mindate"]).toFixed(0)).format("$obs.label.time_summaries_month");
                jQuery(".month_outTemp_min").prop("title", "$obs.label.summaries_date_ttt" + value);
            }
            if (data.hasOwnProperty("month_outTemp_maxdate")) {
                var value = tzAdjustedMoment(parseFloat(data["month_outTemp_maxdate"]).toFixed(0)).format("$obs.label.time_summaries_month");
                jQuery(".month_outTemp_max").prop("title", "$obs.label.summaries_date_ttt" + value);
            }
            if (data.hasOwnProperty("month_barometer_mindate")) {
                var value = tzAdjustedMoment(parseFloat(data["month_barometer_mindate"]).toFixed(0)).format("$obs.label.time_summaries_month");
                jQuery(".month_barometer_min").prop("title", "$obs.label.summaries_date_ttt" + value);
            }
            if (data.hasOwnProperty("month_barometer_maxdate")) {
                var value = tzAdjustedMoment(parseFloat(data["month_barometer_maxdate"]).toFixed(0)).format("$obs.label.time_summaries_month");
                jQuery(".month_barometer_max").prop("title", "$obs.label.summaries_date_ttt" + value);
            }
            if (data.hasOwnProperty("month_rainRate_maxdate")) {
                var value = tzAdjustedMoment(parseFloat(data["month_rainRate_maxdate"]).toFixed(0)).format("$obs.label.time_summaries_month");
                jQuery(".month_rainRate_max").prop("title", "$obs.label.summaries_date_ttt" + value);
            }
            if (data.hasOwnProperty("month_wind_maxdate")) {
                var value = tzAdjustedMoment(parseFloat(data["month_wind_maxdate"]).toFixed(0)).format("$obs.label.time_summaries_month");
                jQuery(".month_wind_max").prop("title", "$obs.label.summaries_date_ttt" + value);
            }
        } catch (err) {
            console.error("Error update_with_mqtt_data", err);
        }

        // update pressure trend values
        try {
            if (vdp_array.hasOwnProperty("pressure_trend")) {
                if (vdp_array["pressure_trend"].hasOwnProperty("obs")) {
                    var vals = vdp_array["pressure_trend"]["obs"];
                    for (var i = 0; i < vals.length; i++) {
                        if (data.hasOwnProperty("trend_" + vals[i])) {
                            update_pressure_trend_properties(weewx_data, vals[i], data["trend_" + vals[i]], ["all"]);
                        }
                    }
                }
            }
        } catch (err) {
            console.error("Error update_with_mqtt_data", err);
        }

        // battery properties
        try {
            if (vdp_array.hasOwnProperty("batt")) {
                if (vdp_array["batt"].hasOwnProperty("obs")) {
                    var vals = vdp_array["batt"]["obs"];
                }
                if (vdp_array["batt"].hasOwnProperty("group")) {
                    var groups = vdp_array["batt"]["group"];
                }
                if (vals.length == groups.length) {
                    for (var i = 0; i < vals.length; i++) {
                        if (data.hasOwnProperty(vals[i])) {
                            update_battery_properties(weewx_data, vals[i], groups[i], data[vals[i]], ["all"]);
                        }
                    }
                }
            }
        } catch (err) {
            console.error("Error update_with_mqtt_data", err);
        }

        // voltage properties
        try {
            if (vdp_array.hasOwnProperty("voltage")) {
                if (vdp_array["voltage"].hasOwnProperty("obs")) {
                    var vals = vdp_array["voltage"]["obs"];
                }
                if (vdp_array["voltage"].hasOwnProperty("group")) {
                    var groups = vdp_array["voltage"]["group"];
                }
                if (vals.length == groups.length) {
                    for (var i = 0; i < vals.length; i++) {
                        if (data.hasOwnProperty(vals[i])) {
                            update_voltage_properties(weewx_data, vals[i], groups[i], data[vals[i]], ["all"]);
                        }
                    }
                }
            }
        } catch (err) {
            console.error("Error update_with_mqtt_data", err);
        }

        // signal properties
        try {
            if (vdp_array.hasOwnProperty("sig")) {
                if (vdp_array["sig"].hasOwnProperty("obs")) {
                    var vals = vdp_array["sig"]["obs"];
                    for (var i = 0; i < vals.length; i++) {
                        if (data.hasOwnProperty(vals[i])) {
                            update_signal_properties(weewx_data, vals[i], data[vals[i]], ["all"]);
                        }
                    }
                }
            }
        } catch (err) {
            console.error("Error update_with_mqtt_data", err);
        }

        // switch properties
        try {
            if (vdp_array.hasOwnProperty("switch")) {
                if (vdp_array["switch"].hasOwnProperty("obs")) {
                    var vals = vdp_array["switch"]["obs"];
                }
                if (vdp_array["switch"].hasOwnProperty("group")) {
                    var groups = vdp_array["switch"]["group"];
                }
                if (vals.length == groups.length) {
                    for (var i = 0; i < vals.length; i++) {
                        if (data.hasOwnProperty(vals[i])) {
                            update_switch_properties(weewx_data, vals[i], groups[i], data[vals[i]], ["all"]);
                        }
                    }
                }
            }
        } catch (err) {
            console.error("Error update_with_mqtt_data", err);
        }

        // room climate properties
        try {
            update_roomclimate_properties(data, ["all"]);
        } catch (err) {
            console.error("Error update_with_mqtt_data", err);
        }

        //TODO
        // sunshine debug symbol and text
        try {
            if (data.hasOwnProperty("sunshine")) {
                if (parseInt(data["sunshine"]) > 0) {
                    jQuery(".debug_sunshine_symbol").attr('style', 'padding-left: 5px;');
                    jQuery(".debug_sunshine_symbol").html('<i class="fa fa-fw fa-sun-o"></i>');
                    jQuery(".sunshine_text").html("$gettext('yes')");
                } else {
                    jQuery(".debug_sunshine_symbol").html("");
                    jQuery(".debug_sunshine_symbol").removeAttr("style");
                    jQuery(".sunshine_text").html("$gettext('no')");
                }
            } else {
                jQuery(".sunshineThreshold").html("$gettext('No evaluation available')");
                jQuery(".sunshine_text").html("");
            }

            // cloudcover debug symbol
            var debug_output = '';
            if (data.hasOwnProperty("lightning_strike_count_sum10m") && parseFloat(data["lightning_strike_count_sum10m"]) > 0.0) {
                debug_output = '<i class="wi wi-lightning"></i>';
            } else if (data.hasOwnProperty("rain_sum10m") && parseFloat(data["rain_sum10m"]) > 0.0) {
                debug_output = '<i class="wi wi-rain"></i>';
            } else if (data.hasOwnProperty("radiation") && data.hasOwnProperty("sunshineRadiationMin") && data.hasOwnProperty("sunshine_avg10m")) {
                if (parseFloat(data["radiation"]) >= parseFloat(data["sunshineRadiationMin"])) {
                    var sunshine_avg10m = parseFloat(data["sunshine_avg10m"]).toFixed(1);
                    if (sunshine_avg10m == 0.0) {
                        debug_output = '<i class="wi wi-cloudy"></i>';
                    } else if (sunshine_avg10m == 1.0) {
                        debug_output = '<i class="wi wi-day-sunny"></i>';
                    } else if (sunshine_avg10m > 0.0 && sunshine_avg10m < 1.0) {
                        debug_output = '<i class="wi wi-day-cloudy"></i>';
                    }
                }
            }
            if (debug_output != "") {
                jQuery(".debug_cloudcover_symbol").attr('style', 'padding-left: 5px;');
            } else {
                jQuery(".debug_cloudcover_symbol").removeAttr("style");
            }
            jQuery(".debug_cloudcover_symbol").html(debug_output);
        } catch (err) {
            console.error("Error update_with_mqtt_data", err);
        }
    } else if (pageName == "mqttmon") {
        // Update the MQTT Monitor page
        // Get all span elements within the table. This is setup by Python initially

        var mqttmon_data_formatted = (mqttmon_format_user == mqttmon_format_default);
        var data_received_ts =  moment().unix();

        try {
            jQuery.each(data, function(data_class, data_raw) {
                if (!jQuery('.' + data_class).length > 0) {
                    console.log("class not exists", data_class);
                    return true;
                }
                // update element as received
                jQuery('.' + data_class + '-mqttmon-rcv-dot').css('background-color', 'var(--mqttmon-rcv-dot-current)');
                jQuery('.' + data_class).data('received_ts', data_received_ts);

                if (!unit_rounding_array.hasOwnProperty(data_class)) {
                    unit_rounding_array[data_class] = unit_rounding_array["default"]
                }
                if (!unit_label_array.hasOwnProperty(data_class)) {
                    unit_label_array[data_class] = unit_label_array["default"]
                }

                // update raw data
                if (data_raw == null) {
                    data_raw = "";
                }
                jQuery('.' + data_class).data('raw', data_raw);

                // update format data
                var data_formatted = data_raw;
                if (unit_group_array.hasOwnProperty(data_class)) {
                    if (unit_group_array[data_class].includes("group_time")) {
                        if (data_class != "cdc_MESS_DATUM") {
                            //data_formatted = tzAdjustedMoment(parseFloat(data_raw).toFixed(0)).format("$obs.label.time_mqtt_monitor");
                            data_formatted = tzAdjustedMoment(parseInt(data_raw)).format("$obs.label.time_mqtt_monitor");
                        }
                   } else {
                        var localeStringUseGrouping = true;
                        if (unit_group_array[data_class].includes("group_time") || unit_group_array[data_class].includes("group_pressure")) {
                            // Do not group number into thousands,hundreds format
                            localeStringUseGrouping = false;
                        }
                        data_formatted = parseFloat(parseFloat(data_raw)).toLocaleString("$system_locale_js", {minimumFractionDigits: unit_rounding_array[data_class], maximumFractionDigits: unit_rounding_array[data_class], useGrouping: localeStringUseGrouping}) + unit_label_array[data_class];
                    }
                }

                // update element formatted data
                jQuery('.' + data_class).data('formatted', data_formatted);

                // Finally update element text
                if (mqttmon_data_formatted) {
                    jQuery("." + data_class).text(data_formatted);
                    // general tooltip
                    jQuery("." + data_class).prop("title", data_raw);
                } else {
                    jQuery("." + data_class).text(data_raw);
                    // general tooltip
                    jQuery("." + data_class).prop("title", data_formatted);
                }

                // Correct beaufort tooltip
                if (data_class == "beaufort") {
                    jQuery("." + data_class).prop("title", beaufort_cat(parseInt(data["beaufort"])));
                }
            });
        } catch (err) {
            console.error("Error MQTT Monitor update_with_mqtt_data", err);
        }

        // mark outdated topics
        mqttmon_mark_outdated();

        //
        // Correct value dependent properties (colors, tooltip, values as text etc.)
        //
/*
        if (mqttmon_data_formatted) {
            #if $Extras.has_key("aqi_enabled") and $Extras.aqi_enabled == '1'
            // aqi properties
            try {
                if (vdp_array.hasOwnProperty("aqi")) {
                    if (vdp_array["aqi"].hasOwnProperty("obs")) {
                        var vals = vdp_array["aqi"]["obs"];
                        for (var i = 0; i < vals.length; i++) {
                            if (data.hasOwnProperty(vals[i])) {
                                update_aqi_properties(weewx_data, vals[i], data[vals[i]], ["title"]);
                            }
                        }
                    }
                }
            } catch (err) {
                console.error("Error update_with_mqtt_data", err);
            }
            #end if

            // pressure trend properties
            try {
                if (vdp_array.hasOwnProperty("pressure_trend")) {
                    if (vdp_array["pressure_trend"].hasOwnProperty("obs")) {
                        var vals = vdp_array["pressure_trend"]["obs"];
                        for (var i = 0; i < vals.length; i++) {
                            if (data.hasOwnProperty("trend_" + vals[i])) {
                                update_pressure_trend_properties(weewx_data, vals[i], data["trend_" + vals[i]], ["title"]);
                            }
                        }
                    }
                }
            } catch (err) {
                console.error("Error update_with_mqtt_data", err);
            }

            // battery properties
            try {
                if (vdp_array.hasOwnProperty("batt")) {
                    if (vdp_array["batt"].hasOwnProperty("obs")) {
                        var vals = vdp_array["batt"]["obs"];
                    }
                    if (vdp_array["batt"].hasOwnProperty("group")) {
                        var groups = vdp_array["batt"]["group"];
                    }
                    if (vals.length == groups.length) {
                        for (var i = 0; i < vals.length; i++) {
                            if (data.hasOwnProperty(vals[i])) {
                                update_battery_properties(weewx_data, vals[i], groups[i], data[vals[i]], ["title"]);
                            }
                        }
                    }
                }
            } catch (err) {
                console.error("Error update_with_mqtt_data", err);
            }

            // voltage properties
            try {
                if (vdp_array.hasOwnProperty("voltage")) {
                    if (vdp_array["voltage"].hasOwnProperty("obs")) {
                        var vals = vdp_array["voltage"]["obs"];
                    }
                    if (vdp_array["voltage"].hasOwnProperty("group")) {
                        var groups = vdp_array["voltage"]["group"];
                    }
                    if (vals.length == groups.length) {
                        for (var i = 0; i < vals.length; i++) {
                            if (data.hasOwnProperty(vals[i])) {
                                update_voltage_properties(weewx_data, vals[i], groups[i], data[vals[i]], ["title"]);
                            }
                        }
                    }
                }
            } catch (err) {
                console.error("Error update_with_mqtt_data", err);
            }

            // signal properties
            try {
                if (vdp_array.hasOwnProperty("sig")) {
                    if (vdp_array["sig"].hasOwnProperty("obs")) {
                        var vals = vdp_array["sig"]["obs"];
                        for (var i = 0; i < vals.length; i++) {
                            if (data.hasOwnProperty(vals[i])) {
                                update_signal_properties(weewx_data, vals[i], data[vals[i]], ["title"]);
                            }
                        }
                    }
                }
            } catch (err) {
                console.error("Error update_with_mqtt_data", err);
            }

            // switch properties
            try {
                if (vdp_array.hasOwnProperty("switch")) {
                    if (vdp_array["switch"].hasOwnProperty("obs")) {
                        var vals = vdp_array["switch"]["obs"];
                    }
                    if (vdp_array["switch"].hasOwnProperty("group")) {
                        var groups = vdp_array["switch"]["group"];
                    }
                    if (vals.length == groups.length) {
                        for (var i = 0; i < vals.length; i++) {
                            if (data.hasOwnProperty(vals[i])) {
                                update_switch_properties(weewx_data, vals[i], groups[i], data[vals[i]], ["title"]);
                            }
                        }
                    }
                }
            } catch (err) {
                console.error("Error update_with_mqtt_data", err);
            }

            // room climate properties
            try {
                update_roomclimate_properties(data, ["title"]);
            } catch (err) {
                console.error("Error update_with_mqtt_data", err);
            }
        }
*/
    }
};
#end if

Highcharts.setOptions({
    global: {
        //useUTC: false
        timezoneOffset: $highcharts_timezoneoffset
    },
    lang: {
        months: moment.months(),
        shortMonths: moment.monthsShort(),
        weekdays: moment.weekdays(),
        shortWeekdays: moment.weekdaysShort(),
        decimalPoint: "$highcharts_decimal",
        thousandsSep: "$highcharts_thousands"
    }
});

function showChart(json_file, prepend_renderTo = false) {

    // Relative URL by finding what page we're on currently.
    jQuery.getJSON(get_relative_url() + '/json/' + json_file + '.json', function(data) {

        // Loop through each chart name (e.g. chart1, chart2, chart3)
        jQuery.each(data, function(plotname, obsname) {
            var observation_type = undefined;

            // Ignore the Weiherhammer Version since this "plot" has no other options
            if (plotname == "weiherhammer_version") {
                return true;
            }

            // Ignore the generated timestamp since this "plot" has no other options
            if (plotname == "generated_timestamp") {
                return true;
            }

            // Ignore the chartgroup_title since this "plot" has no other options
            if (plotname == "chartgroup_title") {
                return true;
            }

            // Set the chart's tooltip date time format, then return since this "plot" has no other options
            if (plotname == "tooltip_date_format") {
                tooltip_date_format = obsname;
                return true;
            }

            // Set the chart colors, then return right away since this "plot" has no other options
            if (plotname == "colors") {
                colors = obsname.split(",");
                return true;
            }

            // Set the chart credits, then return right away since this "plot" has no other options
            if (plotname == "credits") {
                credits = obsname.split(",")[0];
                return true;
            }

            // Set the chart credits url, then return right away since this "plot" has no other options
            if (plotname == "credits_url") {
                credits_url = obsname.split(",")[0];
                return true;
            }

            // Set the chart credits position, then return right away since this "plot" has no other options
            if (plotname == "credits_position") {
                credits_position = obsname;
                return true;
            }

            // Loop through each chart options
            jQuery.each(data[plotname]["options"], function(optionName, optionVal) {
                switch (optionName) {
                    case "type":
                        type = optionVal;
                        break;
                    case "renderTo":
                        renderTo = optionVal;
                        break;
                    case "title":
                        title = optionVal;
                        break;
                    case "subtitle":
                        subtitle = optionVal;
                        break;
                    case "yAxis_label":
                        yAxis_label = optionVal;
                        break;
                    case "chart_group":
                        chart_group = optionVal;
                        break;
                    case "gapsize":
                        gapsize = optionVal;
                        break;
                    case "connectNulls":
                        connectNulls = optionVal;
                        break;
                    case "rounding":
                        rounding = optionVal;
                        break;
                    case "xAxis_categories":
                        xAxis_categories = optionVal;
                        break;
                    case "plot_tooltip_date_format":
                        plot_tooltip_date_format = optionVal;
                        break;
                    case "css_class":
                        css_class = optionVal;
                        break;
                    case "css_height":
                        css_height = optionVal;
                        break;
                    case "css_width":
                        css_width = optionVal;
                        break;
                    case "legend":
                        legend_enabled = optionVal;
                        break;
                    case "exporting":
                        exporting_enabled = optionVal;
                        break;
                }
            });

            // Handle any per-chart date time format override
            if (typeof plot_tooltip_date_format !== "undefined") {
                var tooltip_date_format = plot_tooltip_date_format;
            }

            var options = {
                chart: {
                    renderTo: '',
                    spacing: [5, 10, 10, 0],
                    type: '',
                    zoomType: 'x'
                },

                exporting: {
                    chartOptions: {
                        chart: {
                            events: {
                                load: function() {
                                    this.title.update({style: {color: '#e5554e'}});

                                    if (sessionStorage.getItem('currentTheme') === 'dark') {
                                        var darktheme_textcolor = '#fff';
                                        for (var i = this.yAxis.length - 1; i >= 0; i--) {
                                            this.yAxis[i].update({
                                                title: {style: {color: darktheme_textcolor}},
                                                labels: {style: {color: darktheme_textcolor}},
                                                gridLineColor: '#707073',
                                                tickColor: '#707073'
                                            });
                                        }

                                        for (var i = this.xAxis.length - 1; i >= 0; i--) {
                                            this.xAxis[i].update({
                                                title: {style: {color: darktheme_textcolor}},
                                                labels: {style: {color: darktheme_textcolor}},
                                                gridLineColor: '#707073',
                                                tickColor: '#707073'
                                            });
                                        }

                                        this.legend.update({itemStyle: {color: darktheme_textcolor}});

                                        //this.credits.update({style:{color: darktheme_textcolor}});

                                        this.subtitle.update({style: {color: darktheme_textcolor}});

                                        this.chartBackground.attr({fill: jQuery(".highcharts-background").css("fill")});
                                    } else {
                                        var lighttheme_textcolor = '#666666';
                                        for (var i = this.yAxis.length - 1; i >= 0; i--) {
                                            this.yAxis[i].update({
                                                title: {style: {color: lighttheme_textcolor}},
                                                labels: {style: {color: lighttheme_textcolor}},
                                            });
                                        }

                                        for (var i = this.xAxis.length - 1; i >= 0; i--) {
                                            this.xAxis[i].update({
                                                title: {style: {color: lighttheme_textcolor}},
                                                labels: {style: {color: lighttheme_textcolor}},
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    },
                    // scale: 1,
                    // width: 1000,
                    // sourceWidth: 1000,
                    enabled: JSON.parse(String(exporting_enabled)) // Convert string to bool
                },

                title: {
                    useHTML: true,
                    text: ''
                },

                subtitle: {
                    text: ''
                },

                legend: {
                    enabled: JSON.parse(String(legend_enabled)) // Convert string to bool
                },

                xAxis: {
                    dateTimeLabelFormats: {
                        day: '%e %b',
                        week: '%e %b',
                        month: '%b %y',
                    },
                    lineColor: '#555',
                    minRange: 900000,
                    minTickInterval: 900000,
                    title: {
                        style: {
                            font: 'bold 12px Lucida Grande, Lucida Sans Unicode, Verdana, Arial, Helvetica, sans-serif'
                        }
                    },
                    ordinal: false,
                    type: 'datetime'
                },

                yAxis: [{
                    endOnTick: true,
                    lineColor: '#555',
                    minorGridLineWidth: 0,
                    startOnTick: true,
                    showLastLabel: true,
                    title: {
                    },
                    opposite: false
                }],

                plotOptions: {
                    area: {
                        lineWidth: 2,
                        gapSize: '',
                        gapUnit: 'value',
                        marker: {
                            enabled: false,
                            radius: 2
                        },
                        threshold: null,
                        softThreshold: true
                    },
                    line: {
                        lineWidth: 2,
                        gapSize: '',
                        gapUnit: 'value',
                        marker: {
                            enabled: false,
                            radius: 2
                        },
                    },
                    spline: {
                        lineWidth: 2,
                        gapSize: '',
                        gapUnit: 'value',
                        marker: {
                            enabled: false,
                            radius: 2
                        },
                    },
                    areaspline: {
                        lineWidth: 2,
                        gapSize: '',
                        gapUnit: 'value',
                        marker: {
                            enabled: false,
                            radius: 2
                        },
                        threshold: null,
                        softThreshold: true
                    },
                    scatter: {
                        gapSize: '',
                        gapUnit: 'value',
                        marker: {
                            radius: 2
                        },
                    },
                },

                // Highstock is needed for gapsize. Disable these 3 to make it look like standard Highcharts
                scrollbar: {
                    enabled: false
                },
                navigator: {
                    enabled: false
                },
                rangeSelector: {
                    enabled: false
                },

                tooltip: {
                    enabled: true,
                    crosshairs: true,
                    dateTimeLabelFormats: {
                        hour: '%e %b %H:%M'
                    },
                    // For locale control with moment.js
                    formatter: function(tooltip) {
                        try {
                            // The first returned item is the header, subsequent items are the points.
                            // Mostly applies to line style charts (line, spline, area)
                            return [tzAdjustedMoment(this.x / 1000).format(tooltip_date_format)].concat(
                                this.points.map(function(point) {
                                    // If observation_type is in the series array, use that otherwise use the obsType
                                    var point_obsType = point.series.userOptions.observation_type ? point.series.userOptions.observation_type : point.series.userOptions.obsType;
                                    var rounding = point.series.userOptions.rounding;
                                    var mirrored = point.series.userOptions.mirrored_value;
                                    var numberFormat = point.series.userOptions.numberFormat ? point.series.userOptions.numberFormat : "";
                                    return '<span style="color:' + point.series.color + '">\u25CF</span> ' + point.series.name + ': ' + highcharts_tooltip_factory(point.y, point_obsType, true, rounding, mirrored, numberFormat);
                                })
                            );
                        } catch (e) {
                            // There's an error so check if it's windDir to apply wind direction label, or if it's a scatter. If none of those revert back to default tooltip.
                            if (this.series.userOptions.obsType == "windDir" || this.series.userOptions.observation_type == "windDir") {
                                // If observation_type is in the series array, use that otherwise use the obsType
                                var point_obsType = this.series.userOptions.observation_type ? this.series.userOptions.observation_type : this.series.userOptions.obsType;
                                var rounding = this.series.userOptions.rounding;
                                var mirrored = this.series.userOptions.mirrored_value;
                                return tzAdjustedMoment(this.x / 1000).format(tooltip_date_format) + '<br><b>' + highcharts_tooltip_factory(this.point.y, point_obsType, true, rounding, mirrored);
                            } else if (this.series.userOptions.type == "scatter") {
                                // Catch anything else that might be a scatter plot. Scatter plots will just show x,y coordinates without this.
                                return '<span style="color:' + this.series.color + '">\u25CF</span> ' + this.series.name + ': ' + Highcharts.numberFormat(this.y);
                            } else {
                                return tooltip.defaultFormatter.call(this, tooltip);
                            }
                        }
                    },
                    split: true,
                },

                credits: {},

                series: [{}]

            };

            // Default options completed, build overrides from JSON and graphs.conf

            // Set the chart render div and title
            if (prepend_renderTo) {
                options.chart.renderTo = json_file + "_" + renderTo;
            } else {
                options.chart.renderTo = renderTo;
            }

            weiherhammer_debug(options.chart.renderTo + ": building a " + type + " chart");

            if (css_class) {
                jQuery("#" + options.chart.renderTo).addClass(css_class);
                weiherhammer_debug(options.chart.renderTo + ": div id is " + options.chart.renderTo + " and adding CSS class: " + css_class);
            }

            options.chart.type = type;
            options.title.text = "<a href='#" + options.chart.renderTo + "'>" + title + "</a>"; // Anchor link to chart for direct linking
            options.subtitle.text = subtitle;
            options.plotOptions.area.gapSize = gapsize;
            options.plotOptions.line.gapSize = gapsize;
            options.plotOptions.spline.gapSize = gapsize;
            options.plotOptions.scatter.gapSize = gapsize;
            if (connectNulls == "true") {
                options.plotOptions.series = {connectNulls: connectNulls};
            }
            options.colors = colors;

            // If we have xAxis categories, reset xAxis and populate it from these options. Also need to reset tooltip since there's no datetime for moment.js to use.
            if (xAxis_categories.length >= 1) {
                weiherhammer_debug(options.chart.renderTo + ": has " + xAxis_categories.length + " xAxis categories. Resetting xAxis and tooltips for grouping");
                options.xAxis = {}
                options.xAxis.categories = xAxis_categories;
                options.tooltip = {}
                options.tooltip = {
                    enabled: true,
                    crosshairs: true,
                    split: true,
                    formatter: function() {
                        // The first returned item is the header, subsequent items are the points
                        return [this.x].concat(
                            this.points.map(function(point) {
                                // If observation_type is in the series array, use that otherwise use the obsType
                                var point_obsType = point.series.userOptions.observation_type ? point.series.userOptions.observation_type : point.series.userOptions.obsType;
                                var rounding = point.series.userOptions.rounding;
                                var mirrored = point.series.userOptions.mirrored_value;
                                var numberFormat = point.series.userOptions.numberFormat ? point.series.userOptions.numberFormat : "";
                                return "<span style='color:" + point.series.color + "'>\u25CF</span> " + point.series.name + ': ' + highcharts_tooltip_factory(point.y, point_obsType, true, rounding, mirrored, numberFormat);
                            })
                        );
                    },
                }
            }

            // Reset the series everytime we loop.
            options.series = [];

            // Build the series
            var i = 0;
            jQuery.each(data[plotname]["series"], function(seriesName, seriesVal) {
                observation_type = data[plotname]["series"][seriesName]["obsType"];
                options.series[i] = data[plotname]["series"][seriesName];
                i++;
            });

            /* yAxis customization handler and label handling
            Take the following example. 
            yAxis is in observation 0 (rainTotal), so that label is caught and set by yAxis1_active. 
            If you move yAxis to observation 1 (rainRate), then the label is caught and set by yAxis_index.
            There may be a more efficient way to do this. If so, please submit a pull request :)
            [[[chart3]]]
                title = Rain
                [[[[rainTotal]]]]
                    name = Rain Total
                    yAxis = 1
                [[[[rainRate]]]]
            */

            var yAxis1_active = undefined;

            // Find if any series have yAxis = 1. If so, save the array number so we can set labels correctly.
            // We really care if yAxis is in array 1+, so we can go back and set yAxis 0 to the right label.
            var yAxis_index = options.series.findIndex(function(item) {return item.yAxis == 1})

            // Handle series specific data, overrides and non-Highcharts options that we passed through
            options.series.forEach(s => {
                if (s.yAxis == "1") {
                    // If yAxis = 1 is set for the observation, add a new yAxis and associate that observation to the right side of the chart
                    yAxis1_active = true;
                    options.yAxis.push({ // Secondary yAxis
                        opposite: true,
                        title: {
                            text: s.yAxis_label,
                        },
                    }),
                        // Associate this series to the new yAxis 1
                        s.yAxis = 1

                    // We may have already passed through array 0 in the series without setting the "multi axis label", go back and explicitly define it.
                    if (yAxis_index >= 1) {
                        options.yAxis[0].title.text = options.series[0].yAxis_label;
                    }
                } else {
                    if (yAxis1_active) {
                        // This yAxis is first in the data series, so we can set labels without needing to double back
                        options.yAxis[0].title.text = s.yAxis_label;
                    } else {
                        // Apply the normal yAxis 0's label without observation name
                        options.yAxis[0].title.text = s.yAxis_label;
                    }
                    // Associate this series to yAxis 1
                    s.yAxis = 0;
                }

                // Run yAxis customizations
                // yAxis AQI PlotLines
                // https://github.com/poblabs/weewx-belchertown/issues/682
                // TODO external config

                this_yAxis = s.yAxis;

                // yAxis AQI PlotLines PM10
                // PM10 Umweltbundesamt LQI levels, labels and colors
                // https://www.umweltbundesamt.de/berechnungsgrundlagen-luftqualitaetsindex
                if (s.obsType.includes('pm10_0')) {
                    var yAxis_plotlines = [];

                    const plconf = [{
                        color: "#50F0E6",
                        label: "$gettext('very good')",
                        level: 20
                    }, {
                        color: "#50CDAA",
                        label: "$gettext('good')",
                        level: 35
                    }, {
                        color: "#F0E641",
                        label: "$gettext('moderate')",
                        level: 50
                    }, {
                        color: "#FF5050",
                        label: "$gettext('poor')",
                        level: 100
                    }, {
                        color: "#960032",
                        label: "$gettext('very poor')",
                        level: 200
                    }];

                    for (i = 0; i < plconf.length; i++) {
                        yAxis_plotlines.push({
                            color: plconf[i].color,
                            value: plconf[i].level,
                            label: {
                                text: plconf[i].label,
                                x: 0,
                                y: 15,
                                style: {
                                    color: plconf[i].color
                                }
                            },
                            width: 1,
                            dashStyle: 'Dash',
                            zIndex : 3
                        });
                    }

                    // Add plotlines to yAxis options
                    options.yAxis[this_yAxis].plotLines = yAxis_plotlines;
                }

                // yAxis AQI PlotLines PM2.5
                // PM2.5 LQI levels, labels and colors
                // https://de.euronews.com/wetter/copernicus-air-quality-index
                if (s.obsType.includes('pm2_5')) {
                    var yAxis_plotlines = [];

                    const plconf = [{
                        color: "#50F0E6",
                        label: "$gettext('very good')",
                        level: 10
                    }, {
                        color: "#50CDAA",
                        label: "$gettext('good')",
                        level: 20
                    }, {
                        color: "#F0E641",
                        label: "$gettext('moderate')",
                        level: 25
                    }, {
                        color: "#FF5050",
                        label: "$gettext('poor')",
                        level: 50
                    }, {
                        color: "#960032",
                        label: "$gettext('very poor')",
                        level: 200
                    }];

                    for (i = 0; i < plconf.length; i++) {
                        yAxis_plotlines.push({
                            color: plconf[i].color,
                            value: plconf[i].level,
                            label: {
                                text: plconf[i].label,
                                x: 0,
                                y: 15,
                                style: {
                                    color: plconf[i].color
                                }
                            },
                            width: 1,
                            dashStyle: 'Dash',
                            zIndex : 3
                        });
                    }

                    // Add plotlines to yAxis options
                    options.yAxis[this_yAxis].plotLines = yAxis_plotlines;
                }

                // yAxis AQI PlotLines NO2
                // NO2 Umweltbundesamt LQI levels, labels and colors
                // https://www.umweltbundesamt.de/berechnungsgrundlagen-luftqualitaetsindex
                if (s.obsType == "uba_no2") {
                    var yAxis_plotlines = [];

                    const plconf = [{
                        color: "#50F0E6",
                        label: "$gettext('very good')",
                        level: 20
                    }, {
                        color: "#50CDAA",
                        label: "$gettext('good')",
                        level: 40
                    }, {
                        color: "#F0E641",
                        label: "$gettext('moderate')",
                        level: 100
                    }, {
                        color: "#FF5050",
                        label: "$gettext('poor')",
                        level: 200
                    }, {
                        color: "#960032",
                        label: "$gettext('very poor')",
                        level: 300
                    }];

                    for (i = 0; i < plconf.length; i++) {
                        yAxis_plotlines.push({
                            color: plconf[i].color,
                            value: plconf[i].level,
                            label: {
                                text: plconf[i].label,
                                x: 0,
                                y: 15,
                                style: {
                                    color: plconf[i].color
                                }
                            },
                            width: 1,
                            dashStyle: 'Dash',
                            zIndex : 3
                        });
                    }

                    // Add plotlines to yAxis options
                    options.yAxis[this_yAxis].plotLines = yAxis_plotlines;
                }

                // yAxis AQI PlotLines O3
                // O3 Umweltbundesamt LQI levels, labels and colors
                // https://www.umweltbundesamt.de/berechnungsgrundlagen-luftqualitaetsindex
                if (s.obsType == "uba_o3") {
                    var yAxis_plotlines = [];

                    const plconf = [{
                        color: "#50F0E6",
                        label: "$gettext('very good')",
                        level: 60
                    }, {
                        color: "#50CDAA",
                        label: "$gettext('good')",
                        level: 120
                    }, {
                        color: "#F0E641",
                        label: "$gettext('moderate')",
                        level: 180
                    }, {
                        color: "#FF5050",
                        label: "$gettext('poor')",
                        level: 240
                    }, {
                        color: "#960032",
                        label: "$gettext('very poor')",
                        level: 340
                    }];

                    for (i = 0; i < plconf.length; i++) {
                        yAxis_plotlines.push({
                            color: plconf[i].color,
                            value: plconf[i].level,
                            label: {
                                text: plconf[i].label,
                                x: 0,
                                y: 15,
                                style: {
                                    color: plconf[i].color
                                }
                            },
                            width: 1,
                            dashStyle: 'Dash',
                            zIndex : 3
                        });
                    }

                    // Add plotlines to yAxis options
                    options.yAxis[this_yAxis].plotLines = yAxis_plotlines;
                }

                // yAxis AQI PlotLines SO2
                // SO2 LQI levels, labels and colors
                // https://de.euronews.com/wetter/copernicus-air-quality-index
                if (s.obsType == "aeris_so2") {
                    var yAxis_plotlines = [];

                    const plconf = [{
                        color: "#50F0E6",
                        label: "$gettext('very good')",
                        level: 100
                    }, {
                        color: "#50CDAA",
                        label: "$gettext('good')",
                        level: 200
                    }, {
                        color: "#F0E641",
                        label: "$gettext('moderate')",
                        level: 350
                    }, {
                        color: "#FF5050",
                        label: "$gettext('poor')",
                        level: 500
                    }, {
                        color: "#960032",
                        label: "$gettext('very poor')",
                        level: 1250
                    }];

                    for (i = 0; i < plconf.length; i++) {
                        yAxis_plotlines.push({
                            color: plconf[i].color,
                            value: plconf[i].level,
                            label: {
                                text: plconf[i].label,
                                x: 0,
                                y: 15,
                                style: {
                                    color: plconf[i].color
                                }
                            },
                            width: 1,
                            dashStyle: 'Dash',
                            zIndex : 3
                        });
                    }

                    // Add plotlines to yAxis options
                    options.yAxis[this_yAxis].plotLines = yAxis_plotlines;
                }

                // yAxis PlotLines equivalent temperature "Schwüle"
                // https://github.com/roe-dl/weewx-GTS
                // equivalent temperature levels, labels and colors
                // https://www.spektrum.de/lexikon/geographie/aequivalenttemperatur/437
                if (s.obsType == "outEquiTemp") {
                    var yAxis_plotlines = [];

                    const plconf = [{
                        color: "#FF5733",
                        label: "$pgettext('chart_equivalentTemperature', 'sultriness border')",
                        level: 50
                    }];

                    for (i = 0; i < plconf.length; i++) {
                        yAxis_plotlines.push({
                            color: plconf[i].color,
                            value: plconf[i].level,
                            label: {
                                text: plconf[i].label,
                                x: 0,
                                y: 15,
                                style: {
                                    color: plconf[i].color
                                }
                            },
                            width: 1,
                            dashStyle: 'Dash',
                            zIndex : 3
                        });
                    }

                    // Add plotlines to yAxis options
                    options.yAxis[this_yAxis].plotLines = yAxis_plotlines;
                }

                // yAxis PlotLines GTS, beginning of real spring
                // https://github.com/roe-dl/weewx-GTS
                if (s.obsType == "GTS") {
                    var yAxis_plotlines = [];

                    const plconf = [{
                        color: "#00FF7F",
                        label: "$pgettext('chart_Vegetation', 'springtime border')",
                        level: 200
                    }];

                    for (i = 0; i < plconf.length; i++) {
                        yAxis_plotlines.push({
                            color: plconf[i].color,
                            value: plconf[i].level,
                            label: {
                                text: plconf[i].label,
                                x: 0,
                                y: 15,
                                style: {
                                    color: plconf[i].color
                                }
                            },
                            width: 1,
                            dashStyle: 'Dash',
                            zIndex : 3
                        });
                    }

                    // Add plotlines to yAxis options
                    options.yAxis[this_yAxis].plotLines = yAxis_plotlines;
                }

                // Some charts may require a defined min/max on the yAxis
                options.yAxis[this_yAxis].min = s.yAxis_min !== "undefined" ? s.yAxis_min : null;
                options.yAxis[this_yAxis].max = s.yAxis_max !== "undefined" ? s.yAxis_max : null;

                // Some charts may require a defined soft min/max on the yAxis
                options.yAxis[this_yAxis].softMin = s.yAxis_softMin !== "undefined" ? parseInt(s.yAxis_softMin) : null;
                options.yAxis[this_yAxis].softMax = s.yAxis_softMax !== "undefined" ? parseInt(s.yAxis_softMax) : null;

                // Set the yAxis tick interval. Mostly used for barometer. 
                if (s.yAxis_tickInterval) {
                    options.yAxis[this_yAxis].tickInterval = s.yAxis_tickInterval;
                }

                // Set yAxis minorTicks. This is a graph-wide setting so setting it for any of the yAxis will set it for the graph itself
                if (s.yAxis_minorTicks) {
                    options.yAxis[this_yAxis].minorTicks = true;
                }

                // Barometer chart plots get a higher precision yAxis tick
                if (s.obsType == "barometer") {
                    // Define yAxis label float format if rounding is defined. Default to 2 decimals if nothing defined
                    if (typeof s.rounding !== "undefined") {
                        options.yAxis[this_yAxis].labels = {format: '{value:.' + s.rounding + 'f}'}
                    } else {
                        options.yAxis[this_yAxis].labels = {format: '{value:.2f}'}
                    }
                }

                // Rain, RainRate and rainTotal (special Weiherhammer skin observation) get yAxis precision
                if (s.obsType == "rain" || s.obsType == "rainRate" || s.obsType == "rainTotal") {
                    options.yAxis[this_yAxis].min = 0;
                    options.yAxis[this_yAxis].minRange = 0.01;
                    options.yAxis[this_yAxis].minorGridLineWidth = 1;
                }

                if (s.obsType == "windDir" || s.obsType == "wind") {
                    options.yAxis[this_yAxis].tickInterval = 90;
                    options.yAxis[this_yAxis].labels = {
                        useHTML: true,
                        formatter: function() {var value = weatherdirection[this.value]; return value !== 'undefined' ? value : this.value;}
                    }
                }

                // Check if this series has a gapsize override
                if (s.gapsize) {
                    options.plotOptions.area.gapSize = s.gapsize;
                    options.plotOptions.line.gapSize = s.gapsize;
                    options.plotOptions.spline.gapSize = s.gapsize;
                    options.plotOptions.scatter.gapSize = s.gapsize;
                }

                // If this chart is a mirrored chart, make the yAxis labels non-negative
                if (s.mirrored_value) {
                    weiherhammer_debug(options.chart.renderTo + ": mirrored chart due to mirrored_value = true");
                    options.yAxis[s.yAxis].labels = {formatter: function() {return Math.abs(this.value);}}
                }

                // Lastly, apply any numberFormat label overrides
                if (typeof s.numberFormat !== "undefined" && Object.keys(s.numberFormat).length >= 1) {
                    var {decimals, decimalPoint, thousandsSep} = s.numberFormat
                    options.yAxis[this_yAxis].labels = {formatter: function() {return Highcharts.numberFormat(this.value, decimals, decimalPoint, thousandsSep);}}
                }

            });

            // If windRose is present, configure a special chart to show that data
            if (observation_type == "windRose") {
                #if isinstance($ordinate_names[1], str) is True:
                ## Python 3 unicode string, don't change anything
                var categories = $ordinate_names;
                #else
                ## Python 2 hack to convert backslash unicode to html char
                var categories = #echo[x.encode('ascii', 'xmlcharrefreplace') for x in $ordinate_names] #;
                #end if
                options.chart.className = "highcharts-windRose"; // Used for dark mode
                options.chart.type = "column";
                options.chart.polar = true;
                options.chart.alignTicks = false;
                options.pane = {size: '80%'}
                // Reset xAxis and rebuild
                options.xAxis = {}
                options.xAxis.min = 0;
                options.xAxis.max = 16;
                options.xAxis.crosshair = true;
                options.xAxis.categories = categories;
                options.xAxis.tickmarkPlacement = 'on';
                options.xAxis.labels = {useHTML: true}
                //options.legend.align = "right";
                options.legend.verticalAlign = "top";
                options.legend.x = 210;
                options.legend.y = 119;
                options.legend.layout = "vertical";
                options.legend.floating = true;
                options.yAxis[0].min = 0;
                options.yAxis[0].endOnTick = false;
                options.yAxis[0].reversedStacks = false;
                options.yAxis[0].title.text = "$obs.label.graphs_windrose_frequency (%)";
                options.yAxis[0].gridLineWidth = 0;
                options.yAxis[0].labels = {enabled: false}
                options.yAxis[0].zIndex = 800;
                options.plotOptions = {
                    column: {
                        stacking: 'normal',
                        shadow: false,
                        groupPadding: 0,
                        pointPlacement: 'on',
                    }
                }
                // Reset the tooltip
                options.tooltip = {}
                options.tooltip.outside = true; // https://github.com/poblabs/weewx-belchertown/issues/850
                options.tooltip.shared = true;
                options.tooltip.valueSuffix = '%';
                options.tooltip.followPointer = true;
                options.tooltip.useHTML = true;

                // Since wind rose is a special observation, I did not re-do the JSON arrays to accomodate it as a separate array.
                // So we need to grab the data array within the series and save it to a temporary array, delete the entire chart series, 
                // and reapply the windrose data back to the series.
                var newSeries = options.series[0].data;
                options.series = [];
                newSeries.forEach(ns => {
                    options.series.push(ns);
                });
            }

            // Configure gauge chart formatting
            if (options.chart.type == "gauge") {
                // Highcharts does not allow the guage background to have rounded ends. To get around
                // this, define a "dummy" series that fills the gauge with the appropriate color.
                // This way, the ends are rounded if the user specifies.
                //
                // Gauge chart works best with only one data point, so the most recent (last) data point
                // is used
                options.series[0].data = [{
                    y: 9999999,
                    color: '#e6e6e6',
                    className: 'highcharts-pane',
                    zIndex: 0,
                    dataLabels: {enabled: false}
                }, {
                    y: options.series[0].data.pop()[1],
                    color: options.series[0].color,
                }]
                options.chart.type = "solidgauge"
                options.pane = {
                    startAngle: -140,
                    endAngle: 140,
                    background: [{
                        outerRadius: 0,
                        innerRadius: 0,
                    }]
                }
                // If user has set colors_enabled, change the color according to the value
                if (options.series[0].colors_enabled) {
                    options.series[0].data[1].color = get_gauge_color(options.series[0].data[1]["y"], options.series[0])
                }
                options.plotOptions = {
                    solidgauge: {
                        dataLabels: {
                            useHTML: true,
                            enabled: true,
                            borderWidth: 0,
                            style: {
                                fontWeight: 'bold',
                                lineHeight: '0.5em',
                                textAlign: 'center',
                                fontSize: '50px',
                                // Match color if set by user
                                color: options.series[0].data[1].color,
                                textOutline: 'none'
                            }
                        },
                    }
                }

                /*
                if (get_gauge_label(options.series[0].data[1]["y"], options.series[0])) {
                    options.plotOptions.solidgauge.dataLabels.format = "<span style='text-align:center'>{y:.#f}</span><br><span style='font-size:14px;text-align:center'>" + get_gauge_label(options.series[0].data[1]["y"], options.series[0]) + '</span>'
                    options.plotOptions.solidgauge.dataLabels.y = -25
                } else if (unit_label_array[observation_type] == null) {
                    options.plotOptions.solidgauge.dataLabels.format = "<span style='text-align:center'>{y:.#f}</span>"
                } else {
                    options.plotOptions.solidgauge.dataLabels.format = "<span style='text-align:center'>{y:.#f}</span><br><span style='font-size:20px;text-align:center'>" + unit_label_array[observation_type] + '</span>'
                    options.plotOptions.solidgauge.dataLabels.y = -25
                }
                */

                var dataLabel = '<div style="text-align:center;">';
                dataLabel += '<span style="font-size:35px;lineHeight:0.9;">{y:.#f}';
                if (unit_label_array[observation_type] != null) {
                    dataLabel += '</span><span style="font-size:30px;"><sup>' + '&nbsp;' + unit_label_array[observation_type].trim() +'</sup>';
                }
                if (get_gauge_label(options.series[0].data[1]["y"], options.series[0])) {
                    dataLabel +='</span><br/><span style="font-size:18px;opacity:0.5;">' + get_gauge_label(options.series[0].data[1]["y"], options.series[0]);
                }
                dataLabel += '</span></div>';
                options.plotOptions.solidgauge.dataLabels.format = dataLabel;
                options.plotOptions.solidgauge.dataLabels.y = -25;

                options.yAxis = {
                    min: 0,
                    max: 100,
                    lineColor: null,
                    tickPositions: []
                }
                // Override default max and min if user has specified
                if (options.series[0].yAxis_max) {
                    options.yAxis.max = options.series[0].yAxis_max;
                }
                if (options.series[0].yAxis_min) {
                    options.yAxis.min = options.series[0].yAxis_min;
                }
                options.tooltip.enabled = false
                options.xAxis.crosshair = false
                options.credits.enabled = false;
            }

            // If AQI chart is present, configure a special chart
            if (observation_type == "aqiChart") {
                // Highcharts does not allow the guage background to have rounded ends. To get around
                // this, define a "dummy" series that fills the gauge with the appropriate color.
                // This way, the ends are rounded if the user specifies.
                options.series[0].data = [{
                    y: 500,
                    color: '#e6e6e6',
                    className: 'highcharts-pane',
                    zIndex: 0,
                    dataLabels: {enabled: false}
                }, {
                    y: options.series[0].data[0]['y'],
                    color: get_aqi_color(options.series[0].data[0]['y'], true),
                    category: options.series[0].data[0]['category']
                }]
                options.chart.type = "solidgauge"
                options.pane = {
                    startAngle: -140,
                    endAngle: 140,
                    background: [{
                        outerRadius: 0,
                        innerRadius: 0,
                    }]
                }
                options.plotOptions = {
                    solidgauge: {
                        dataLabels: {
                            useHTML: true,
                            enabled: true,
                            y: -30,
                            borderWidth: 0,
                            format: '<span style="text-align:center">{y}</span><br><span style="font-size:14px;text-align:center">' + options.series[0].data[1]['category'] + '</span>',
                            style: {
                                fontWeight: 'bold',
                                lineHeight: '0.5em',
                                textAlign: 'center',
                                fontSize: '50px',
                                color: options.series[0].data[1].color,
                                textOutline: 'none'
                            }
                        },
                        linecap: 'round',
                        rounded: true
                    }
                }
                options.yAxis = {
                    min: 0,
                    max: 500,
                    lineColor: null,
                    tickPositions: []
                }
                options.tooltip.enabled = false
                options.xAxis.crosshair = false
            }

            // If Hays chart is present, configure a special chart to show that data
            if (observation_type == "haysChart") {
                options.chart.type = "arearange"
                options.chart.polar = true;
                options.plotOptions = {
                    turboThreshold: 0,
                    series: {
                        marker: {
                            enabled: false
                        }
                    }
                };
                // Find min and max of the series data for the yAxis min and max
                var maximum_flattened = [];
                options.series[0].data.forEach(seriesData => {
                    maximum_flattened.push(seriesData[2]);
                });
                var range_max = Math.max(...maximum_flattened);
                if (options.series[0].yAxis_softMax) {
                    var range_max = options.series[0].yAxis_softMax;
                }
                options.legend = {"enabled": false}
                options.yAxis = {
                    showFirstLabel: false,
                    tickInterval: 2,
                    tickmarkPlacement: 'on',
                    min: -1,
                    softMax: range_max,
                    title: {
                        text: options.series[0].yAxis_label,
                    },
                    labels: {
                        align: 'center',
                        x: 0,
                        y: 0
                    },
                }
                options.tooltip = {
                    split: false,
                    shared: true,
                    followPointer: true,
                    useHTML: true,
                    formatter: function(tooltip) {
                        return this.points.map(function(point) {
                            var rounding = point.series.userOptions.rounding;
                            var mirrored = point.series.userOptions.mirrored_value;
                            var numberFormat = point.series.userOptions.numberFormat ? point.series.userOptions.numberFormat : "";
                            return "<strong>" + tzAdjustedMoment(point.x / 1000).format(tooltip_date_format) + "</strong><br><span style='color:" + options.series[0].color + "'>\u25CF</span> $obs.label.highest_temperature: " + highcharts_tooltip_factory(point.point.high, observation_type, true, rounding, mirrored, numberFormat) + "<br><span style='color:" + options.series[0].color + "'>\u25CF</span> $obs.label.lowest_temperature: " + highcharts_tooltip_factory(point.point.low, observation_type, true, rounding, mirrored, numberFormat);
                        });
                    }
                }
                var currentSeries = options.series;
                var currentSeriesData = options.series[0].data;
                var range_unit = options.series[0].range_unit;
                var rounding = options.series[0].rounding;
                var newSeriesData = [];
                var currentSeriesColor = options.series[0].color;
                currentSeriesData.forEach(seriesData => {
                    newSeriesData.push({
                        x: seriesData[0],
                        low: seriesData[1],
                        high: seriesData[2],
                    });
                });
                options.series = [];
                options.series.push({
                    data: newSeriesData,
                    obsType: "haysChart",
                    obsUnit: range_unit,
                    rounding: rounding,
                    color: currentSeriesColor,
                    fillColor: currentSeriesColor,
                    connectEnds: false,
                });
            }

            // If weather range is present, configure a special chart to show that data
            // https://www.highcharts.com/blog/tutorials/209-the-art-of-the-chart-weather-radials/
            if (observation_type == "weatherRange") {
                if (options.series[0].area_display) {
                    options.chart.type = "arearange";
                } else {
                    options.chart.type = "columnrange";
                }

                // If polar is defined, use it and add a special dark mode CSS class
                if (JSON.parse(String(options.series[0].polar.toLowerCase()))) {
                    options.chart.polar = true; // Make sure the option is a string, then convert to bool
                    options.chart.className = "highcharts-weatherRange weiherhammer-polar"; // Used for dark mode
                } else {
                    options.chart.className = "highcharts-weatherRange"; // Used for dark mode
                }

                options.legend = {"enabled": false}

                // Find min and max of the series data for the yAxis min and max
                var minimum_flattened = [];
                var maximum_flattened = [];
                options.series[0].data.forEach(seriesData => {
                    minimum_flattened.push(seriesData[1]);
                    maximum_flattened.push(seriesData[2]);
                });
                var range_min = Math.min(...minimum_flattened);
                var range_max = Math.max(...maximum_flattened);

                var yAxis_tickInterval = Math.ceil(Math.round(range_max / 5) / 5) * 5; // Divide max outTemp by 5 and round it, then round that value up to the nearest 5th multiple. This gives clean yAxis tick lines. 

                options.yAxis = {
                    showFirstLabel: true,
                    tickInterval: yAxis_tickInterval,
                    min: range_min,
                    max: range_max,
                    title: {
                        text: options.series[0].yAxis_label,
                    },
                }

                options.xAxis = {
                    dateTimeLabelFormats: {
                        day: '%e %b',
                        week: '%e %b',
                        month: '%b %y',
                    },
                    showLastLabel: true,
                    crosshair: true,
                    type: "datetime"
                }

                options.plotOptions = {}
                options.plotOptions = {
                    series: {
                        turboThreshold: 0,
                        showInLegend: false,
                        borderWidth: 0,
                        marker: {
                            enabled: false,
                        },
                    }
                }

                if (options.series[0].area_display) {
                    if (options.series[0].range_unit == "degree_F") {
                        options.plotOptions.series.zones = [
                            {value: 0, color: "#1278c8"},
                            {value: 25, color: "#30bfef"},
                            {value: 32, color: "#1fafdd"},
                            {value: 40, color: "rgba(0,172,223,1)"},
                            {value: 50, color: "#71bc3c"},
                            {value: 55, color: "rgba(90,179,41,0.8)"},
                            {value: 65, color: "rgba(131,173,45,1)"},
                            {value: 70, color: "rgba(206,184,98,1)"},
                            {value: 75, color: "rgba(255,174,0,0.9)"},
                            {value: 80, color: "rgba(255,153,0,0.9)"},
                            {value: 85, color: "rgba(255,127,0,1)"},
                            {value: 90, color: "rgba(255,79,0,0.9)"},
                            {value: 95, color: "rgba(255,69,69,1)"},
                            {value: 110, color: "rgba(255,104,104,1)"},
                            {color: "rgba(218,113,113,1)"},
                        ]
                    } else {
                        options.plotOptions.series.zones = [
                            {value: -5, color: "#1278c8"},
                            {value: -3.8, color: "#30bfef"},
                            {value: 0, color: "#1fafdd"},
                            {value: 4.4, color: "rgba(0,172,223,1)"},
                            {value: 10, color: "#71bc3c"},
                            {value: 12.7, color: "rgba(90,179,41,0.8)"},
                            {value: 18.3, color: "rgba(131,173,45,1)"},
                            {value: 21.1, color: "rgba(206,184,98,1)"},
                            {value: 23.8, color: "rgba(255,174,0,0.9)"},
                            {value: 26.6, color: "rgba(255,153,0,0.9)"},
                            {value: 29.4, color: "rgba(255,127,0,1)"},
                            {value: 32.2, color: "rgba(255,79,0,0.9)"},
                            {value: 35, color: "rgba(255,69,69,1)"},
                            {value: 43.3, color: "rgba(255,104,104,1)"},
                            {color: "rgba(218,113,113,1)"},
                        ]
                    }
                } else {
                    options.plotOptions.series.stacking = "normal"
                }

                options.tooltip = {
                    split: false,
                    shared: true,
                    followPointer: true,
                    useHTML: true,
                    formatter: function(tooltip) {
                        return this.points.map(function(point) {
                            var rounding = point.series.userOptions.rounding;
                            var mirrored = point.series.userOptions.mirrored_value;
                            var numberFormat = point.series.userOptions.numberFormat ? point.series.userOptions.numberFormat : "";
                            return "<strong>" + tzAdjustedMoment(point.x / 1000).format(tooltip_date_format) + "</strong><br><span style='color:" + get_outTemp_color(point.series.userOptions.obsUnit, point.point.high, true) + "'>\u25CF</span> $obs.label.highest_temperature: " + highcharts_tooltip_factory(point.point.high, observation_type, true, rounding, mirrored, numberFormat) + "<br><span style='color:" + get_outTemp_color(point.series.userOptions.obsUnit, point.point.low, true) + "'>\u25CF</span> $obs.label.lowest_temperature: " + highcharts_tooltip_factory(point.point.low, observation_type, true, rounding, mirrored, numberFormat) + "<br><span style='color:" + get_outTemp_color(point.series.userOptions.obsUnit, point.point.average, true) + "'>\u25CF</span> $obs.label.average_temperature: " + highcharts_tooltip_factory(point.point.average, observation_type, true, rounding, mirrored, numberFormat);
                        });
                    }
                }

                // Update data
                var currentSeries = options.series;
                var currentSeriesData = options.series[0].data;
                var range_unit = options.series[0].range_unit;
                var rounding = options.series[0].rounding;
                var newSeriesData = [];
                currentSeriesData.forEach(seriesData => {
                    if (options.series[0].color) {
                        var color = options.series[0].color;
                    } else {
                        // Set color of the column based on the average temperature, or return default if not temperature
                        var color = get_outTemp_color(range_unit, seriesData[3], true);
                    }
                    newSeriesData.push({
                        x: seriesData[0],
                        low: seriesData[1],
                        high: seriesData[2],
                        average: seriesData[3],
                        color: color
                    });
                });
                options.series = [];
                options.series.push({
                    data: newSeriesData,
                    obsType: "weatherRange",
                    obsUnit: range_unit,
                    rounding: rounding
                });
            }

            // Apply any width, height CSS overrides to the parent div of the chart
            if (css_height != "") {
                jQuery("#" + options.chart.renderTo).parent().css({
                    'height': css_height,
                    'padding': '0px 15px',
                    'margin-bottom': '20px'
                });
            }
            if (css_width != "") {
                jQuery("#" + options.chart.renderTo).parent().css('width', css_width);
            }

            if (credits != "highcharts_default") {
                options.credits.text = credits;
            }

            if (credits_url != "highcharts_default") {
                options.credits.href = credits_url;
            }

            if (credits_position != "highcharts_default") {
                options.credits.position = JSON.parse(credits_position);
            }

            // Finally all options are done, now show the chart
            var chart = new Highcharts.chart(options);

            // If using debug, show a copy paste debug for use with jsfiddle
            weiherhammer_debug(options);
            weiherhammer_debug("Highcharts.chart('container', " + JSON.stringify(options) + ");");

        });

    });

};

function tzAdjustedMoment(input) {
    let tz = "$moment_js_tz";
    if (!tz) {
        return moment.unix(input).utcOffset($moment_js_utc_offset);
    } else {
        return moment.unix(input).tz(tz);
    }
}
